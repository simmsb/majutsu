\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename majutsu.info
@settitle Majutsu User Manual
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@dircategory Emacs
@direntry
* Majutsu: (majutsu).   Using Jujutsu from Emacs with Majutsu.
@end direntry

@finalout
@titlepage
@title Majutsu User Manual
@subtitle for version 0.6.0
@author 0WD0
@end titlepage

@contents

@ifnottex
@node Top
@top Majutsu User Manual

Majutsu is a Magit-inspired Emacs interface for the Jujutsu (jj) version control system. It provides a powerful, interactive log viewer and a comprehensive set of commands for manipulating revision history with the efficiency and comfort Emacs users expect.

@end ifnottex

@menu
* Introduction::
* Installation::
* Getting Started::
* Interface Concepts::
* Inspecting::
* Manipulating::
* Bookmarks::
* Git Integration::
* Workspaces::
* Conflict Resolution::
* Customizing::
* Template DSL::
* Extending Majutsu::
* Keystroke Index::
* Function and Command Index::
* Variable Index::

@detailmenu
--- The Detailed Node Listing ---

Introduction

* About Majutsu::
* About Jujutsu::
* Acknowledgments::

Installation

* Requirements::
* Installing from Git::
* Post-Installation Tasks::

Installing from Git

* Doom Emacs::
* use-package with straight.el: use-package with straightel. 
* use-package with package-vc::
* Manual Installation::

Interface Concepts

* Buffers and Modes::
* Sections::
* Transient Menus::
* Visual Selection System::
* Completion and Confirmation::
* Running JJ::

Buffers and Modes

* Log Buffer::
* Diff Buffer::
* Blob Buffer::
* Process Buffer::
* JJ description Buffer::

Inspecting

* Log Buffer: Log Buffer (1). 
* Diffing::
* File and Blob Inspection::
* Annotate (Blame)::
* Ediff and Diffedit::
* Process Buffer: Process Buffer (1). 
* Operation Log (Experimental)::

Log Buffer

* Log Display::
* Log Options Transient::
* Revset Builder::

Diffing

* Diff Transient::
* Diff Buffer: Diff Buffer (1). 

Manipulating

* Creating Changes::
* Describing Changes::
* Committing::
* Editing Changes::
* Squashing::
* Absorbing::
* Rebasing::
* Duplicating::
* Abandoning::
* Undo and Redo::
* Splitting::
* Restoring::
* Sparse Working Copy::
* Interactive Patching::

Interactive Patching

* How It Works::
* Diff Context Inheritance::
* Visual Feedback::
* Selection Semantics::
* Technical Implementation::
* Edge Cases::
* Workflow Example::
* Customization::

Bookmarks

* Understanding Bookmarks::
* Bookmark Transient::
* Tracking Remote Bookmarks::

Git Integration

* Git Transient::
* Pushing::
* Fetching::
* Remotes::
* Clone and Init::
* Export and Import::

Workspaces

* Understanding Workspaces::
* Workspace Transient::
* Configuring Workspace Discovery::

Conflict Resolution

* Detecting Conflicts::
* Entering Conflict Mode::
* majutsu-conflict-mode Commands::

Customizing

* Essential Settings::
* Confirmation Settings::
* Process Options::
* Display Options::
* Diff Options::
* Buffer Hooks::
* Description Options::
* Evil Integration::
* Workspace Options::

Template DSL

* Overview::
* Why Use the DSL@?::
* Basic Syntax::
* Method Calls::
* List Operations::
* Operators::
* Conditional and Control Flow::
* Elisp Embedding::
* Defining Custom Functions::
* Type System::
* Supported Commands::

Basic Syntax

* Vectors and Concatenation::
* String Literals::
* Raw Injection::
* Booleans and Numbers::

Method Calls

* Explicit Method Chaining::
* Self-Type Context::

Extending Majutsu

* Module Architecture::
* Process Execution::
* Section Types::
* Transient Definitions::

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

@menu
* About Majutsu::
* About Jujutsu::
* Acknowledgments::
@end menu

@node About Majutsu
@section About Majutsu

Majutsu aims to bring the legendary workflow of Magit to the Jujutsu (jj) version control system. It is not merely a wrapper around the @samp{jj} CLI, but a deeply integrated Emacs environment that leverages Magit's section management and transient menu systems. Majutsu provides visual tools for complex operations like rebasing, squashing, and conflict resolution, making the power of Jujutsu accessible and intuitive.

Originally started as a fork of @samp{jj-mode.el}, Majutsu has been heavily refactored and expanded to include a new template DSL, asynchronous process handling, and a native Evil-mode integration.

@node About Jujutsu
@section About Jujutsu

Jujutsu (jj) is a next-generation version control system that is both simple and powerful. It features a unique "working copy is a commit" model (@@), first-class support for mutable history, and robust conflict management. Unlike Git, jj does not have a staging area; instead, changes in the working copy are automatically recorded into the current revision. This makes it an ideal companion for Emacs, where buffers are often in a state of flux.

@node Acknowledgments
@section Acknowledgments

Majutsu stands on the shoulders of giants. We are grateful to:
@itemize
@item
The Jujutsu community for creating a revolutionary VCS@.
@item
The Magit authors and contributors for defining the gold standard of VCS interfaces.
@item
Brandon Olivier for the initial codebase of @samp{jj-mode.el}.
@end itemize

@node Installation
@chapter Installation

@menu
* Requirements::
* Installing from Git::
* Post-Installation Tasks::
@end menu

@node Requirements
@section Requirements

@itemize
@item
Emacs 29.1 or later.
@item
Jujutsu (jj) v0.37.0 or later installed and in your @samp{PATH}.
@item
@samp{magit} 3.3.0 or later (for section management).
@item
@samp{transient} 0.5.0 or later (popup menus).
@item
@samp{with-editor} (for descriptive message editing).
@end itemize

@node Installing from Git
@section Installing from Git

Majutsu is currently available via GitHub. You can install it using your preferred Emacs package manager.

@menu
* Doom Emacs::
* use-package with straight.el: use-package with straightel. 
* use-package with package-vc::
* Manual Installation::
@end menu

@node Doom Emacs
@subsection Doom Emacs

Add the following to your @samp{packages.el}:
@lisp
(package! majutsu :recipe (:host github :repo "0WD0/majutsu"))
@end lisp

@node use-package with straightel
@subsection use-package with straight.el

@lisp
(use-package majutsu
  :straight (:host github :repo "0WD0/majutsu"))
@end lisp

@node use-package with package-vc
@subsection use-package with package-vc

Emacs 29+ users can use the built-in @samp{package-vc} support:
@lisp
(use-package majutsu
  :vc (:url "https://github.com/0WD0/majutsu"))
@end lisp

@node Manual Installation
@subsection Manual Installation

Clone the repository and add it to your @samp{load-path}:
@lisp
(add-to-list 'load-path "/path/to/majutsu")
(require 'majutsu)
@end lisp

@node Post-Installation Tasks
@section Post-Installation Tasks

If you use Evil mode, Majutsu includes a native integration that provides sensible Vim-like keybindings. It is enabled by default if Evil is detected. You can customize this via @samp{M-x customize-group RET majutsu-evil RET}.

@node Getting Started
@chapter Getting Started

To begin using Majutsu, navigate to a directory within a Jujutsu repository and run @code{M-x majutsu} (or its alias @code{majutsu-log}).

If the directory is not a repository, Majutsu will offer to initialize one using @samp{jj git init}. Once the log buffer opens, you will see a graphical representation of your revision history, similar to Magit's log but with Jujutsu's unique features like hidden and divergent revisions clearly marked.

Navigation is straightforward: use @code{n} and @code{p} to move between revisions, and @code{RET} to visit the revision at point. Press @code{?} at any time to open the Dispatcher, which shows all available commands.

@node Interface Concepts
@chapter Interface Concepts

@menu
* Buffers and Modes::
* Sections::
* Transient Menus::
* Visual Selection System::
* Completion and Confirmation::
* Running JJ::
@end menu

@node Buffers and Modes
@section Buffers and Modes

Majutsu uses several specialized buffer types to provide a rich interface.

@menu
* Log Buffer::
* Diff Buffer::
* Blob Buffer::
* Process Buffer::
* JJ description Buffer::
@end menu

@node Log Buffer
@subsection Log Buffer

The primary interface for Majutsu. It displays the revision graph, working copy status, and active workspaces. It uses @samp{majutsu-log-mode}, derived from @samp{magit-section-mode}.

@node Diff Buffer
@subsection Diff Buffer

Displays changes between revisions or within the working copy. It supports Magit-style hunk and file sections, word-level refinement, and interactive patching.

@node Blob Buffer
@subsection Blob Buffer

Allows viewing the contents of a file at a specific revision. You can navigate through the file's history using @code{n} and @code{p} within the blob buffer.

@node Process Buffer
@subsection Process Buffer

Shows the output of background @samp{jj} commands. If a command fails, you can press @code{$} to inspect the error.

@node JJ description Buffer
@subsection JJ description Buffer

Used for writing commit descriptions or other interactive input. It uses @samp{with-editor} to ensure seamless integration with the Emacs environment.

JJ descriptions buffers highlight metadata blocks and change summaries. You can customize @code{majutsu-jjdescription-major-mode}, @code{majutsu-jjdescription-comment-prefix}, @code{majutsu-jjdescription-change-id-face}, and @code{global-majutsu-jjdescription-mode} to taste. JJ comment commands use @code{JJ:} as the comment prefix. @code{JJ: ignore-rest} marks the remainder of the buffer as comment. Other major modes are not thoroughly tested yet. Jujutsu currently does not support changing the comment prefix; the option is reserved for future compatibility.

@node Sections
@section Sections

Majutsu organizes information into collapsible sections. You can use @code{TAB} to toggle the visibility of a section (e.g., a revision's description in the log, or a file in a diff).

@node Transient Menus
@section Transient Menus

Commands in Majutsu are grouped into "transient" menus. These popups allow you to select options and flags before executing a command. For example, pressing @code{r} opens the Rebase transient.

@node Visual Selection System
@section Visual Selection System

For commands like Rebase, Squash, or Absorb, Majutsu uses a visual selection system. You can mark "source" and "destination" revisions directly in the log buffer, and they will be highlighted with distinct colors until the operation is executed or cleared.

@node Completion and Confirmation
@section Completion and Confirmation

Majutsu integrates with Emacs' completion system (like Vertico or Ivy) for selecting bookmarks, remotes, and revsets. Revset completion candidates are annotated with source labels (pseudo/workspace/bookmark/tag) to make ambiguous names easier to identify. Destructive operations like @code{abandon} or @code{undo} will prompt for confirmation.

@node Running JJ
@section Running JJ

Majutsu runs @samp{jj} commands asynchronously whenever possible to keep the Emacs UI responsive. Large log graphs or remote operations won't freeze your editor.

@node Inspecting
@chapter Inspecting

@menu
* Log Buffer: Log Buffer (1). 
* Diffing::
* File and Blob Inspection::
* Annotate (Blame)::
* Ediff and Diffedit::
* Process Buffer: Process Buffer (1). 
* Operation Log (Experimental)::
@end menu

@node Log Buffer (1)
@section Log Buffer

The log buffer is the heart of Majutsu. It displays the history graph using a custom template DSL that mirrors the @samp{jj log} output but adds interactivity.

@menu
* Log Display::
* Log Options Transient::
* Revset Builder::
@end menu

@node Log Display
@subsection Log Display

Each revision in the log is a section. You can see the change ID, bookmarks, tags, and the first line of the description. Collapsed by default, you can expand a revision to see its full description.

@node Log Options Transient
@subsection Log Options Transient

Press @code{l} to open the log options. Here you can:
@table @asis
@item @code{r}
Set a revset filter (e.g., @samp{all()} or @samp{mine()}).
@item @code{-n}
Limit the number of revisions shown.
@item @code{-v}
Toggle reverse order.
@item @code{-G}
Toggle the ASCII graph.
@item @code{a}
Add a path filter to see only changes affecting certain files.
@end table

@node Revset Builder
@subsection Revset Builder

While you can type revsets manually, Majutsu's selection system allows you to build them interactively. Commands that require a revset will often default to the revision at point or your current selection.

@node Diffing
@section Diffing

@menu
* Diff Transient::
* Diff Buffer: Diff Buffer (1). 
@end menu

@node Diff Transient
@subsection Diff Transient

Press @code{d} to open the Diff transient.
@table @asis
@item @code{r}
Select revisions to diff (@samp{--revisions}). Can specify multiple revisions or a revset like @samp{B::D}.
@item @code{f} / @code{t}
Select the @samp{--from} and @samp{--to} revisions.
@item @code{--}
Limit diff to selected files/filesets.
@item @code{-g}
Toggle Git-style diff output.
@item @code{-W}
Toggle color-words diff output.
@item @code{-S}
Toggle stat output.
@item @code{-s}
Toggle summary output.
@item @code{-c}
Set context line count.
@item @code{-b} / @code{-w}
Ignore whitespace amount / ignore all whitespace.
@end table

@enumerate
@item
@anchor{Understanding @samp{--revisions}}Understanding @samp{--revisions}


The @samp{--revisions} argument accepts any revset that forms a @emph{contiguous} set of commits. "Contiguous" means no gaps in the DAG, but @strong{forks and merges are allowed}.

Examples:
@table @asis
@item @samp{-r @@}
Changes in the working copy commit (default).
@item @samp{-r @@-}
Changes in the parent of the working copy.
@item @samp{-r B::D}
Total changes from B through D@.
@item @samp{-r 'A | B'}
Valid only if A and B form a contiguous set; gaps produce an error.
@end table

When visiting a file from such a diff:
@itemize
@item
On an @strong{added} or @strong{context} line: visits @samp{heads(revisions)}.
@item
On a @strong{removed} line: visits @samp{roots(revisions)-} (the parents of roots).
@end itemize

@strong{Note}: When the revset has multiple heads or roots, the target revision for file visits may be ambiguous. For example, in an X-shaped history:
@example
D   E       <- two heads
 \ /
  C
 / \
A   B       <- two roots
@end example
If you diff @samp{-r A::D | B::E}, there are two heads (D, E) and two roots (A, B). The diff shows changes from the @emph{merged} parents to the @emph{merged} heads. If D and E modify the same lines, the diff will show conflict markers. When visiting files, Majutsu picks one of the heads/roots, which may not be the specific commit where the displayed change originated. For precise navigation, use @samp{--from} / @samp{--to} with single revisions instead.
@end enumerate

@node Diff Buffer (1)
@subsection Diff Buffer

The diff buffer is highly interactive:
@table @asis
@item @code{RET}
Visit the appropriate version of the file at point. For working copy diffs, visits the actual file. For committed changes, visits the blob.
@item @code{C-j} / @code{C-<return>}
Visit the workspace file, regardless of diff type. Note: when Evil mode is active, @code{C-j} may be overridden by Evil's section navigation; use @code{C-<return>} instead, which is unaffected.
@item @code{v} (on a file section)
Open a blob buffer for that file using the current diff context.
@item @code{+} / @code{-}
Increase or decrease the amount of context shown.
@item @code{t}
Toggle word-level refinement.
@end table

When @samp{--color-words} is enabled, Majutsu renders the old/new line numbers in
the left margin and uses "@dots{}" lines to split hunks.
With refinement enabled, color-words hunks also show a shadow cursor on the
paired side (controlled by @samp{smerge-refine-shadow-cursor}).
Navigation (@samp{RET} / @samp{C-j}) still respects the side at point by using stored
line/column metadata from the color-words backend.

@node File and Blob Inspection
@section File and Blob Inspection

Majutsu's file inspector is implemented by @samp{majutsu-file} and can be used both
from command prompts and directly from sections in log/diff buffers.

@table @asis
@item @code{M-x majutsu-find-file}
Prompt for revset + path and open that file as a blob.
@item @code{M-x majutsu-find-file-at-point}
Open the file at point using section context.
@end table

Blob buffers are read-only snapshots with history-aware navigation:
@table @asis
@item @code{p} / @code{n}
Jump to previous/next revision that touched this file (while preserving cursor position as much as possible).
@item @code{V}
Jump to the workspace version of the same file.
@item @code{C-c m}
Open the current blob in Magit's blob viewer.
@item @code{b}
Start annotate for the current blob.
@item @code{g}
Revert/reload the current blob content.
@item @code{e} / @code{C-x C-q}
Enter editable blob mode (wdired-style).
@itemize
@item
Blob navigation keys are disabled while editing, so blob-mode bindings do not interfere with text edits.
@item
Save (or @code{C-c C-c}) applies changes through non-interactive @samp{jj diffedit} and exits edit mode.
Majutsu copies current buffer text into the diffedit right side and finishes automatically, without opening the right-side temp file buffer.
@item
In editable mode, @code{C-x C-q} runs @code{majutsu-blob-edit-exit}:
@itemize
@item
If modified, it prompts to save or abort.
@item
Save applies via diffedit; abort restores original content and cursor position.
@item
If unchanged, it exits immediately.
@end itemize
@item
In Evil:
@itemize
@item
In blob mode, @code{i} enters editable blob mode and stays in normal state.
@item
In editable mode, @code{i} enters insert state.
@end itemize
@item
Editable mode also changes cursor visuals (see @code{majutsu-blob-edit-cursor-type}); with Evil, normal-state cursor is updated too.
@end itemize
@end table

@node Annotate (Blame)
@section Annotate (Blame)

Majutsu annotate is implemented by @samp{majutsu-annotate} and uses
@samp{jj file annotate} under the hood.

@itemize
@item
Entry: run @code{b} (@code{majutsu-annotate-addition}) from a blob/file buffer.
@item
Recursive trace: currently only forward recursive annotate is supported.
Running @code{b} again on an annotated chunk jumps to its parent revision (when
available) and re-annotates there.
@item
Styles: @code{majutsu-annotate-cycle-style} is available. In default
read-only annotate bindings, press @code{c} to cycle heading/highlight/line styles
(@samp{majutsu-annotate-styles}).
@item
Navigation: @code{n} / @code{p} for next/previous chunk, @code{N} / @code{P} for next/previous
chunk from the same commit.
@item
Inspection: @code{RET} shows the chunk's revision diff, @code{M-w} copies the chunk
change-id, and @code{SPC} / @code{S-SPC} scroll the diff window if it is already open.
@end itemize

@node Ediff and Diffedit
@section Ediff and Diffedit

Press @code{E} in dispatcher to open @samp{majutsu-ediff} transient.

@itemize
@item
Selection: choose revisions via @samp{--revisions} or @samp{--from} / @samp{--to} (with
point-toggle variants). In diff buffers, current range is used as default.
@item @code{e} (@samp{majutsu-ediff-dwim})
Compare based on context (hunk/file/commit/whole
buffer).
@item @code{E} (@samp{majutsu-ediff-edit})
Run @samp{jj diffedit} with Emacs as
@samp{ui.diff-editor}. If no file is at point, Majutsu prompts for a changed file,
then launches a two-sided Ediff session for that single file (left/right
temp files). Edit and save as needed, then quit Ediff to return control to
@samp{jj diffedit}. When @samp{majutsu-edit-finish-on-save} is non-nil, saving can
finish the with-editor session automatically.
@end itemize

Conflict resolution is now a separate command:
@table @asis
@item @code{m} in dispatcher (@samp{majutsu-ediff-resolve})
Resolve conflicted files.
Uses @samp{jj resolve} with 3-way Ediff (merge tool: @samp{$left}, @samp{$base}, @samp{$right})
for 2-sided conflicts, and falls back to @samp{jj diffedit} for conflicts with
more than 2 sides.
In a @samp{jj-commit} section, conflicted files are listed for that revision.
@end table

@node Process Buffer (1)
@section Process Buffer

Press @code{$} (Emacs) or @code{`} (Evil) to see the output of the last @samp{jj} command. This is essential for debugging failed operations or viewing long-running output like remote fetches.

@node Operation Log (Experimental)
@section Operation Log (Experimental)

Jujutsu tracks every operation that modifies the repository. Press @code{M-x majutsu-op-log} to view this history. You can see when commands were run and by whom.

@node Manipulating
@chapter Manipulating

@menu
* Creating Changes::
* Describing Changes::
* Committing::
* Editing Changes::
* Squashing::
* Absorbing::
* Rebasing::
* Duplicating::
* Abandoning::
* Undo and Redo::
* Splitting::
* Restoring::
* Sparse Working Copy::
* Interactive Patching::
@end menu

@node Creating Changes
@section Creating Changes

@table @asis
@item @code{O}
Create a new change on top of the revision at point (DWIM).
@item @code{o}
Open the New transient to specify options.
@item @code{A}
Create a new change after the revision at point.
@item @code{B} (Emacs), @code{I} (Evil log mode)
Create a new change before the revision at point.
@end table

Transient options:
@table @asis
@item @code{-r}
Parent revisions.
@item @code{-A}
Insert after constraint.
@item @code{-B}
Insert before constraint.
@item @code{-m}
Set a message.
@item @code{-e}
No edit (don't switch to the new change).
@end table
Runs: @samp{jj new -r REV}

@node Describing Changes
@section Describing Changes

@table @asis
@item @code{c} (@code{majutsu-describe})
Edit the description of the revision at point. Supports @samp{--ignore-immutable} flag for immutable revisions.
@end table
Runs: @samp{jj describe -r REV}

@node Committing
@section Committing

@table @asis
@item @code{C} (@code{majutsu-commit})
In Jujutsu, "commit" usually means finishing the current work. This command opens a description buffer for the working copy.
@end table
Runs: @samp{jj commit}

@node Editing Changes
@section Editing Changes

@table @asis
@item @code{e} (@code{majutsu-edit-changeset})
Move the working copy (@@) to the revision at point. Supports @samp{--ignore-immutable} flag for immutable revisions.
@end table
Runs: @samp{jj edit REV}

@node Squashing
@section Squashing

@table @asis
@item @code{s} (@code{majutsu-squash})
Open the Squash transient. You can select multiple source revisions (@samp{--from}) to squash into a destination (@samp{--into}).
@item @code{-r}
Revision to squash.
@item @code{-f}
Source revisions (@samp{--from}).
@item @code{-t}
Destination revision (@samp{--into}).
@item @code{-o}
Onto destination.
@item @code{-A} / @code{-B}
Insert after/before constraints.
@item @code{-m}
Set a message for the result.
@end table
Runs: @samp{jj squash --from SRC --into DEST}

@node Absorbing
@section Absorbing

@table @asis
@item @code{a} (Emacs/Evil), or @code{?} then @code{A} (@code{majutsu-absorb})
Open the Absorb transient.
@item @code{-f}
Source revision (@samp{--from}, default @samp{@@}).
@item @code{-t}
Destination revset filter (@samp{--into}, default @samp{mutable()}).
@item @code{--}
Limit absorb to specific filesets.
@end table
Runs: @samp{jj absorb --from REV --into REVSET [FILESETS...]}

@node Rebasing
@section Rebasing

@table @asis
@item @code{r} (@code{majutsu-rebase})
Open the Rebase transient. This is one of Majutsu's most powerful features, allowing you to visually select sources and destinations.
@item @code{-s}
Rebase a specific revision.
@item @code{-b}
Rebase an entire branch.
@item @code{-o}
Specify the destination (@samp{--onto}).
@end table
Runs: @samp{jj rebase -s SRC -o DEST}

@node Duplicating
@section Duplicating

@table @asis
@item @code{y} (@code{majutsu-duplicate})
Open the Duplicate transient. Allows selecting source revisions and destination.
@item @code{Y} (@code{majutsu-duplicate-dwim})
Duplicate the revision at point onto its current parent.
@item @code{-r}
Source revisions to duplicate.
@item @code{-o}
Destination (@samp{--onto}).
@item @code{-A} / @code{-B}
Insert after/before constraints.
@end table
Runs: @samp{jj duplicate -r REV}

@node Abandoning
@section Abandoning

@table @asis
@item @code{k} (Emacs), @code{x} (Evil)
Abandon the revision at point. Its changes are lost, and its descendants are rebased.
With an active region selection, Majutsu abandons all selected revisions.
@end table
Runs: @samp{jj abandon -r REV}

@node Undo and Redo
@section Undo and Redo

@table @asis
@item Emacs: @code{C-/} / @code{C-?}
Undo / Redo
@item Evil: @code{u} / @code{C-r}
Undo / Redo
@end table
Runs: @samp{jj undo} or @samp{jj redo}

@node Splitting
@section Splitting

@table @asis
@item @code{S} (@code{majutsu-split})
Open the Split transient. This allows you to split a revision into multiple parts.
@item @code{-r}
Specify the revision to split.
@item @code{-o}
Specify the destination (@samp{--onto}).
@item @code{-A} / @code{-B}
Insert after/before constraints.
@item @code{-m}
Set a message for the first part.
@item @code{-p}
Parallel split mode.
@item @code{--}
Limit split to selected files/filesets.
@end table
Runs: @samp{jj split -r REV [FILESETS...]}

@node Restoring
@section Restoring

@table @asis
@item @code{R} (@code{majutsu-restore})
Open the Restore transient for undoing changes.
@item @code{-f}
Restore from a specific revision (@samp{--from}).
@item @code{-t}
Restore to a specific revision (@samp{--to}).
@item @code{-c}
Undo changes introduced by a revision (@samp{--changes-in}).
@item @code{-d}
Restore descendants as well.
@item @code{--}
Limit restore to selected files/filesets.
@end table
Runs: @samp{jj restore --from REV [FILESETS...]} or @samp{jj restore --changes-in REV [FILESETS...]}

@node Sparse Working Copy
@section Sparse Working Copy

@table @asis
@item @code{>} (@code{majutsu-sparse})
Open the sparse working copy transient (set, add, remove, list, edit).
@item
Editing patterns opens a temporary @samp{.jjsparse} buffer; lines starting with @code{JJ:} are comments and are ignored by Jujutsu.
@end table

Sparse transient actions:
@table @asis
@item @code{l}
List current sparse patterns in @samp{*Majutsu Sparse*} buffer.
@item @code{s} / @code{S}
Set patterns (append / replace with clear first).
@item @code{a} / @code{r}
Add or remove patterns incrementally.
@item @code{e}
Edit patterns via @samp{jj sparse edit} (with @samp{majutsu-jjsparse-mode}).
@item @code{R}
Reset to all files (@samp{jj sparse reset}).
@end table

Notes:
@itemize
@item
Pattern completion includes current directories/files from @samp{@@}.
@item
Default "all files" state is represented by single pattern @samp{.}.
@end itemize

@node Interactive Patching
@section Interactive Patching

Majutsu provides Magit-style partial hunk selection for Jujutsu operations. This allows you to select specific hunks, files, or even regions within hunks to include in Split, Squash, or Restore operations.

@menu
* How It Works::
* Diff Context Inheritance::
* Visual Feedback::
* Selection Semantics::
* Technical Implementation::
* Edge Cases::
* Workflow Example::
* Customization::
@end menu

@node How It Works
@subsection How It Works

Interactive selection is integrated into the Split (@code{S}), Squash (@code{s}), and Restore (@code{R}) transients. When you open one of these transients from a Diff buffer, a "Patch Selection" group appears with the following commands:

@multitable {aaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Description
@item @code{H}
@tab majutsu-interactive-toggle-hunk
@tab Toggle selection of hunk at point
@item @code{F}
@tab majutsu-interactive-toggle-file
@tab Toggle selection of all hunks in file
@item @code{R}
@tab majutsu-interactive-toggle-region
@tab Toggle selection of active region
@item @code{C}
@tab majutsu-interactive-clear
@tab Clear all patch selections
@end multitable

@node Diff Context Inheritance
@subsection Diff Context Inheritance

When opening Split, Squash, or Restore from a Diff buffer, the transient automatically inherits the diff's context:
@itemize
@item
All three commands inherit @samp{--revisions} as their target revision (@samp{--revision} for Split/Squash)
@item
Restore additionally inherits @samp{--from} and @samp{--to} parameters, allowing selective restoration between arbitrary revisions
@end itemize

This means you can:
@enumerate
@item
View a diff with specific @samp{--from} / @samp{--to} revisions
@item
Open the Restore transient
@item
Select specific hunks to restore
@item
The restore will apply only to those hunks, using the diff's revision context
@end enumerate

@node Visual Feedback
@subsection Visual Feedback

Selected hunks are highlighted with @samp{majutsu-interactive-selected-hunk} face (green background by default). Selected regions within hunks use @samp{majutsu-interactive-selected-region} face (purple background).

@node Selection Semantics
@subsection Selection Semantics

The meaning of "selected" differs by operation:

@enumerate
@item
@anchor{Split and Squash}Split and Squash


For Split and Squash, @strong{selected content is what gets moved}:
@itemize
@item
@strong{Split}: Selected hunks/regions go into the @strong{first} commit; unselected content stays in the second commit.
@item
@strong{Squash}: Selected hunks/regions get @strong{squashed into the parent}; unselected content remains in the current revision.
@end itemize

Example: You have a revision with changes to files A, B, and C@. You want to squash only the changes to file A into the parent:
@enumerate
@item
Open the diff for the revision (@code{D})
@item
Open Squash transient (@code{s})
@item
Press @code{F} on file A to select all its hunks
@item
Execute squash - file A's changes go to parent, B and C stay
@end enumerate

@item
@anchor{Restore}Restore


For Restore, selected content is what gets @strong{restored} (undone):
@itemize
@item
Selected hunks/regions are reverted to their state in the source revision
@item
Unselected content is left unchanged
@end itemize
@end enumerate

@node Technical Implementation
@subsection Technical Implementation

Majutsu uses a custom merge tool to apply partial patches. When you execute an operation with selections:

@enumerate
@item
@strong{Patch Generation}: Majutsu generates a unified diff patch containing only the selected hunks/regions.

@item
@strong{Tool Invocation}: Jujutsu's @samp{-i --tool} mechanism is used with a custom @samp{majutsu-applypatch} tool.

@item
@strong{Patch Application}:
@itemize
@item
For @strong{Split/Squash}: The tool resets @samp{$right} (current state) to @samp{$left} (parent state), then applies the patch forward. This results in @samp{$right} containing only the selected changes.
@item
For @strong{Restore}: The tool applies the patch directly to @samp{$right}.
@end itemize
@end enumerate

This approach avoids the complexity of reverse patch application (@samp{git apply -R}), which has edge cases with new files, deleted files, and content starting with @samp{+} or @samp{-}.

@node Edge Cases
@subsection Edge Cases

Interactive patching supports all file operation types:

@enumerate
@item
@anchor{New Files}New Files


When splitting or squashing a new file:
@itemize
@item
If you select the entire file, it goes to the first commit / gets squashed
@item
If you select only part of the file, only those lines go; the rest stays
@item
Partial selection of new files works correctly because the patch is applied forward after resetting to parent state
@end itemize

@item
@anchor{Deleted Files}Deleted Files


@strong{Note: Interactive selection for deleted files is currently limited.}

When splitting or squashing a file deletion:
@itemize
@item
Selecting the @strong{entire} deletion works correctly - the file gets deleted in the first commit / parent
@item
@strong{Partial selection of deleted files is not yet supported} - you must select all lines or none
@end itemize

This limitation exists because git's patch format requires @samp{deleted file mode} patches to remove the entire file contents. Partial deletion would require converting to a regular modification patch, which has edge cases with context matching.

@item
@anchor{Renamed/Copied Files}Renamed/Copied Files


Renamed and copied files are handled correctly:
@itemize
@item
The rename/copy metadata is preserved in the patch
@item
You can select specific hunks within renamed files just like regular modifications
@end itemize
@end enumerate

@node Workflow Example
@subsection Workflow Example

@enumerate
@item
Open a diff with @code{D} or @code{d}
@item
Open Split (@code{S}), Squash (@code{s}), or Restore (@code{R}) transient
@item
Use @code{H} to select individual hunks, or @code{F} to select all hunks in a file
@item
For fine-grained control, mark a region and press @code{R} to select only those lines
@item
Press @code{C} to clear selections if needed
@item
Execute the operation - only selected changes will be affected
@end enumerate

@node Customization
@subsection Customization

@table @asis
@item @samp{majutsu-interactive-selected-hunk}
Face for selected hunks
@item @samp{majutsu-interactive-selected-region}
Face for selected regions
@end table

@node Bookmarks
@chapter Bookmarks

@menu
* Understanding Bookmarks::
* Bookmark Transient::
* Tracking Remote Bookmarks::
@end menu

@node Understanding Bookmarks
@section Understanding Bookmarks

In Jujutsu, bookmarks are similar to Git branches but are explicitly tracked. They point to a specific change ID@.

@node Bookmark Transient
@section Bookmark Transient

Press @code{b} to manage bookmarks.
@table @asis
@item @code{l}
List all bookmarks.
@item @code{c}
Create a new bookmark at point.
@item @code{s}
Set (move) an existing bookmark to point to the current revision.
@item @code{m}
Move a bookmark.
@item @code{M}
Move bookmark(s) with @samp{--allow-backwards}.
@item @code{r}
Rename a bookmark.
@item @code{d}
Delete a bookmark (this deletion propagates to remotes).
@item @code{f}
Forget a bookmark (removes local tracking without affecting remotes).
@end table

@node Tracking Remote Bookmarks
@section Tracking Remote Bookmarks

@table @asis
@item @code{t}
Track a remote bookmark to create a local one.
@item @code{u}
Untrack a remote bookmark.
@end table

@node Git Integration
@chapter Git Integration

@menu
* Git Transient::
* Pushing::
* Fetching::
* Remotes::
* Clone and Init::
* Export and Import::
@end menu

@node Git Transient
@section Git Transient

Press @code{G} to access Git-specific commands. Jujutsu can interact directly with Git remotes.

@node Pushing
@section Pushing

@table @asis
@item @code{p}
Open the Push transient. You can push specific bookmarks or all tracked bookmarks.
@item @code{-a}
Push all tracked bookmarks.
@item @code{-b}
Push specific bookmark(s).
@item @code{-c}
Push a specific change.
@item @code{-r}
Push specific revision(s).
@item @code{--allow-new}
Allow creating new remote bookmarks.
@item @code{--dry-run}
Show what would be pushed without pushing.
@end table
Runs: @samp{jj git push}

@node Fetching
@section Fetching

@table @asis
@item @code{f}
Open the Fetch transient to pull changes from a remote.
@item @code{-b}
Fetch specific bookmark(s).
@item @code{-r}
Fetch from specific remote.
@item @code{--all-remotes}
Fetch from all remotes.
@end table
Runs: @samp{jj git fetch}

@node Remotes
@section Remotes

@table @asis
@item @code{r}
Open the Remote Management transient.
@item @code{l}
List remotes.
@item @code{a}
Add a new Git remote.
@item @code{d}
Remove a remote.
@item @code{n}
Rename a remote.
@item @code{u}
Set remote URL@.
@end table

@node Clone and Init
@section Clone and Init

@table @asis
@item @code{c}
Clone a Git repository into a jj repo.
@item @code{i}
Initialize a new Git-backed jj repository.
@end table

@node Export and Import
@section Export and Import

Jujutsu automatically exports/imports to the underlying Git repo, but you can trigger it manually:
@table @asis
@item @code{e}
@samp{jj git export}
@item @code{m}
@samp{jj git import}
@item @code{o}
Show Git directory path (@samp{jj git root})
@end table

@node Workspaces
@chapter Workspaces

@menu
* Understanding Workspaces::
* Workspace Transient::
* Configuring Workspace Discovery::
@end menu

@node Understanding Workspaces
@section Understanding Workspaces

Jujutsu supports multiple workspaces sharing the same repository storage. This is similar to Git worktrees but more integrated.

@node Workspace Transient
@section Workspace Transient

Press @code{Z} or @code{%} (Emacs) or @code{*} (Evil) to manage workspaces.
@table @asis
@item @code{l}
List all workspaces.
@item @code{v}
Visit a workspace (only changes default-directory, and refresh majutsu buffers).
@item @code{a}
Add a new workspace.
@item @code{f}
Forget a workspace.
@item @code{u}
Update a stale workspace.
@item @code{n}
Rename a workspace.
@item @code{r}
Show and copy current workspace root.
@end table

@node Configuring Workspace Discovery
@section Configuring Workspace Discovery

If Majutsu cannot find a workspace on disk, it will prompt you. You can configure @samp{majutsu-workspace-search-directories} to help it find them automatically.

@node Conflict Resolution
@chapter Conflict Resolution

@menu
* Detecting Conflicts::
* Entering Conflict Mode::
* majutsu-conflict-mode Commands::
@end menu

@node Detecting Conflicts
@section Detecting Conflicts

JJ marks conflicts in the log with a "conflict" label. Expanding the revision will show which files are conflicted.

@node Entering Conflict Mode
@section Entering Conflict Mode

You can enter conflict handling from multiple places:
@itemize
@item
In dispatcher, use @code{m} (@samp{majutsu-ediff-resolve}) for auto resolve flow.
@item
In a diff hunk, use @code{C-c ^ RET} (@samp{majutsu-diff-resolve-conflict}).
@item
In Ediff transient, use @code{m} (auto strategy) or @code{M} (force conflict workflow).
@code{M} opens the working-copy file (or a revision blob buffer for non-working-copy
revisions), enables @samp{majutsu-conflict-mode}, and jumps to the first conflict.
@item
Manually, run @code{M-x majutsu-conflict-ensure-mode} in a file with conflict markers.
@end itemize

@samp{majutsu-conflict} auto-detects marker styles:
@itemize
@item
JJ conflict markers (@samp{%%%%%%%} / @samp{+++++++} / @samp{-------} ) -> enable @samp{majutsu-conflict-mode}.
@item
JJ long conflict markers (e.g., 15-char marker runs) are treated the same as normal markers.
@item
JJ conflicts with missing terminating newline markers are parsed with jj's newline-compensation semantics.
@item
Git-style markers (@samp{|||||||} / @samp{=====}) only -> enable @samp{smerge-mode}.
@end itemize

@node majutsu-conflict-mode Commands
@section majutsu-conflict-mode Commands

Default key prefix is @code{C-c ^}:
@table @asis
@item @code{n} / @code{p}
Jump to next/previous conflict.
@item @code{b}
Keep conflict base (snapshot / rebase destination section).
@item @code{1..9}
Keep side N ("after" side in JJ diff blocks).
@item @code{M-1..M-9}
Keep side N "before" variant.
@item @code{R}
Refine conflict regions with word-level highlighting.
@end table

In Evil integration:
@table @asis
@item @code{]]} / @code{[[} or @code{gj} / @code{gk}
Next/previous conflict.
@item @code{gb}
Keep base.
@item @code{gr} and @code{gR}
Resolve "after" / "before" side maps.
@item @code{ge}
Refine.
@end table

@node Customizing
@chapter Customizing

@menu
* Essential Settings::
* Confirmation Settings::
* Process Options::
* Display Options::
* Diff Options::
* Buffer Hooks::
* Description Options::
* Evil Integration::
* Workspace Options::
@end menu

@node Essential Settings
@section Essential Settings

@table @asis
@item @code{majutsu-jj-executable}
Path to the @samp{jj} binary (default: @samp{"jj"}).
@item @code{majutsu-jj-global-arguments}
Global arguments passed to all jj commands (default: @samp{("--no-pager" "--color=always")}).
@item @code{majutsu-show-process-buffer-hint}
Whether to show the "Type $ for details" hint on errors.
@item @code{majutsu-debug}
Enable debug logging for jj operations.
@item @code{majutsu-show-command-output}
Show jj command output in messages.
@end table

@node Confirmation Settings
@section Confirmation Settings

@table @asis
@item @code{majutsu-confirm-critical-actions}
If non-nil, prompt for confirmation before critical operations like abandon, undo, redo, rebase.
@item @code{majutsu-no-confirm}
A list of symbols for actions Majutsu should not confirm, or @samp{t} to never confirm. Valid symbols: @samp{undo}, @samp{redo}, @samp{abandon}, @samp{rebase}, @samp{workspace-forget}.
@item @code{majutsu-slow-confirm}
A list of actions that should use @samp{yes-or-no-p} instead of @samp{y-or-n-p}.
@end table

@node Process Options
@section Process Options

@table @asis
@item @code{majutsu-process-popup-time}
Popup the process buffer if a command takes longer than this many seconds. @samp{-1} means never, @samp{0} means immediately.
@item @code{majutsu-process-log-max}
Maximum number of sections to keep in a process log buffer (default: 32).
@item @code{majutsu-process-apply-ansi-colors}
When non-nil, convert ANSI escapes in jj output to text properties.
@item @code{majutsu-process-timestamp-format}
Format string for timestamps in process buffer sections.
@end table

@node Display Options
@section Display Options

@table @asis
@item @code{majutsu-log-commit-columns}
Customize which columns are shown in the log (ID, author, date, etc.).
@item @code{majutsu-log-field-faces}
Customize the colors used for different fields in the log.
@item @code{majutsu-log-sections-hook}
Hook run to insert sections in the log buffer.
@item @code{majutsu-display-buffer-function}
Magit-style display strategy (default: @samp{majutsu-display-buffer-traditional}; traditional, same-window-except-diff, fullframe, topleft, fullcolumn).
@item @code{majutsu-pre-display-buffer-hook}
Hook run before displaying a buffer.
@item @code{majutsu-post-display-buffer-hook}
Hook run after displaying a buffer.
@item @code{majutsu-bury-buffer-function}
Function used by @code{q} to bury/quit Majutsu buffers (default: @samp{majutsu-mode-quit-window}; alternatives include @samp{quit-window} and @samp{majutsu-restore-window-configuration}).
@end table

@node Diff Options
@section Diff Options

@table @asis
@item @code{majutsu-diff-refine-hunk}
Whether to show word-granularity differences inside hunks. @samp{nil} disables, @samp{t} refines current hunk, @samp{'all} refines all hunks.
@item @code{majutsu-diff-refine-ignore-whitespace}
Whether to ignore whitespace while refining hunks.
@item @code{majutsu-diff-refine-max-chars}
Skip word refinement when a hunk spans more than this many characters.
@item @code{majutsu-diff-paint-whitespace}
Whether to highlight whitespace issues inside diff hunks.
@item @code{majutsu-diff-highlight-trailing}
Whether to mark trailing whitespace in diff hunks.
@end table

@node Buffer Hooks
@section Buffer Hooks

@table @asis
@item @code{majutsu-create-buffer-hook}
Normal hook run when a new Majutsu buffer is created.
@item @code{majutsu-setup-buffer-hook}
Normal hook run after displaying the buffer.
@item @code{majutsu-post-create-buffer-hook}
Normal hook run after the initial refresh.
@item @code{majutsu-refresh-buffer-hook}
Normal hook run after refreshing.
@end table

@node Description Options
@section Description Options

@table @asis
@item @code{majutsu-jjdescription-major-mode}
Major mode used for editing JJ description buffers (default: @code{text-mode}).
@item @code{majutsu-jjdescription-comment-prefix}
Comment prefix used in JJ description buffers (default: @samp{"JJ:"}).
@item @code{majutsu-jjdescription-change-id-face}
Face used for JJ Change ID values.
@item @code{global-majutsu-jjdescription-mode}
Global minor mode to enable JJ description buffer enhancements.
@end table

@node Evil Integration
@section Evil Integration

@table @asis
@item @code{majutsu-evil-enable-integration}
Set to @samp{nil} to disable automatic Evil bindings.
@item @code{majutsu-evil-initial-state}
The Evil state to start in (default: @samp{normal}).
@end table

@node Workspace Options
@section Workspace Options

@table @asis
@item @code{majutsu-workspace-search-directories}
Directories to search when locating workspace roots.
@end table

@node Template DSL
@chapter Template DSL

@menu
* Overview::
* Why Use the DSL@?::
* Basic Syntax::
* Method Calls::
* List Operations::
* Operators::
* Conditional and Control Flow::
* Elisp Embedding::
* Defining Custom Functions::
* Type System::
* Supported Commands::
@end menu

@node Overview
@section Overview

Majutsu includes a domain-specific language (DSL) for building Jujutsu templates in Emacs Lisp. The main entry point is @samp{majutsu-tpl}, which compiles a vector-based DSL form into a jj template string.

@node Why Use the DSL@?
@section Why Use the DSL@?

The DSL provides several advantages over writing raw template strings:

@itemize
@item
@strong{Compile-time validation}: Syntax errors are caught during byte-compilation rather than at runtime when jj executes the template.
@item
@strong{Automatic escaping}: String literals are properly escaped (quotes, backslashes, control characters) without manual intervention.
@item
@strong{Elisp integration}: Embed Elisp expressions that evaluate at compile time, enabling dynamic template generation based on configuration or context.
@item
@strong{Composability}: Define reusable template functions with @samp{majutsu-template-defun} that expand inline, avoiding runtime overhead.
@item
@strong{Type awareness}: The DSL understands jj's type system, enabling self-type context for cleaner keyword syntax (@samp{[:description]} instead of @samp{[:method [:raw "self"] :description]}).
@item
@strong{Readability}: Vector-based syntax with keywords is more readable than deeply nested string concatenation.
@end itemize

Example comparison:
@lisp
;; Raw string (error-prone, hard to read)
"if(self.root(), \"(root)\", self.commit_id().short())"

;; DSL (validated, composable, readable)
(majutsu-tpl [:if [:raw "self.root()"] "(root)" [:method [:raw "self"] :commit_id :short]])
@end lisp

@node Basic Syntax
@section Basic Syntax

@menu
* Vectors and Concatenation::
* String Literals::
* Raw Injection::
* Booleans and Numbers::
@end menu

@node Vectors and Concatenation
@subsection Vectors and Concatenation

Vectors without a leading keyword are implicitly concatenated:
@lisp
(majutsu-tpl ["A" "B"])           ; => "concat(\"A\", \"B\")"
(majutsu-tpl [:concat "A" "B"])   ; => "concat(\"A\", \"B\")"
@end lisp

Bare strings inside vectors are automatically treated as string literals (@samp{:str}).

@node String Literals
@subsection String Literals

Use @samp{:str} for explicit string literals with proper escaping:
@lisp
(majutsu-tpl [:str "Hello \"World\""])  ; => "Hello \"World\""
@end lisp

@node Raw Injection
@subsection Raw Injection

Use @samp{:raw} to inject template code directly without escaping:
@lisp
(majutsu-tpl [:raw "self.commit_id().short()"])  ; => "self.commit_id().short()"
@end lisp

Symbols passed to @samp{:call} are treated as raw identifiers:
@lisp
(majutsu-tpl [:call 'coalesce [:str ""] [:str "X"]])  ; => "coalesce(\"\", \"X\")"
@end lisp

@node Booleans and Numbers
@subsection Booleans and Numbers

Elisp @samp{t} and @samp{nil} map to @samp{true} and @samp{false}. Numbers pass through directly:
@lisp
(majutsu-tpl [:if t "yes" "no"])      ; => "if(true, \"yes\", \"no\")"
(majutsu-tpl [:call 'pad_end 8 "x"])  ; => "pad_end(8, \"x\")"
@end lisp

@node Method Calls
@section Method Calls

@menu
* Explicit Method Chaining::
* Self-Type Context::
@end menu

@node Explicit Method Chaining
@subsection Explicit Method Chaining

Use @samp{:method} to call methods on objects. Methods can be chained:
@lisp
(majutsu-tpl [:method [:raw "self" :Commit] :commit_id])
; => "self.commit_id()"

(majutsu-tpl [:method [:raw "self" :Commit] :parents :len])
; => "self.parents().len()"

(majutsu-tpl [:method [:raw "self" :Commit] :diff "src"])
; => "self.diff(\"src\")"
@end lisp

@node Self-Type Context
@subsection Self-Type Context

When a self-type is provided, bare keywords become method calls on @samp{self}:
@lisp
(majutsu-tpl [:description] 'Commit)      ; => "self.description()"
(majutsu-tpl [:parents :len] 'Commit)     ; => "self.parents().len()"
@end lisp

@node List Operations
@section List Operations

List methods (@samp{map}, @samp{filter}, @samp{any}, @samp{all}) use a special syntax with a binding variable:
@lisp
(majutsu-tpl [:map [:raw "self.bookmarks()"] b [:raw "b.name()"]])
; => "self.bookmarks().map(|b| b.name())"

(majutsu-tpl [:map-join [:str ", "] [:raw "self.parents()"] p [:raw "p.commit_id()"]])
; => "self.parents().map(|p| p.commit_id()).join(\", \")"

(majutsu-tpl [:filter [:raw "parents"] c [:raw "c.mine()"]])
; => "parents.filter(|c| c.mine())"

(majutsu-tpl [:any [:raw "parents"] c [:raw "c.conflict()"]])
; => "parents.any(|c| c.conflict())"
@end lisp

@node Operators
@section Operators

Arithmetic and logical operators are supported:
@lisp
(majutsu-tpl [:+ 1 2])              ; => "(1 + 2)"
(majutsu-tpl [:and [:> 3 1] [:<= 2 2]])  ; => "((3 > 1) && (2 <= 2))"
(majutsu-tpl [:not t])              ; => "(!true)"
(majutsu-tpl [:++ "L" "R"])         ; => "(\"L\" ++ \"R\")"
@end lisp

@node Conditional and Control Flow
@section Conditional and Control Flow

@lisp
(majutsu-tpl [:if [:raw "self.root()"] "(root)" [:raw "self.commit_id()"]])
; => "if(self.root(), \"(root)\", self.commit_id())"

(majutsu-tpl [:separate " " [:label "a" "A"] [:label "b" "B"]])
; => "separate(\" \", label(\"a\", \"A\"), label(\"b\", \"B\"))"
@end lisp

@node Elisp Embedding
@section Elisp Embedding

Elisp expressions are evaluated when the template is compiled.
@lisp
(let* ((tmp 1)
       (s1 `[:concat ,(if (> 2 tmp) [:str "T"] [:str "F"]) [:str "!"]])
       (s2 [:concat (if (> 2 tmp) [:str "T"] [:str "F"]) [:str "!"]])
       (tmp 3))
  (concat (majutsu-tpl s1) (majutsu-tpl s2)))
; => "concat(\"T\", \"!\")concat(\"F\", \"!\")"
@end lisp

@node Defining Custom Functions
@section Defining Custom Functions

Use @samp{majutsu-template-defun} to define reusable template functions:
@lisp
(majutsu-template-defun my-helper ((label Template) (value Template :optional t))
  (:returns Template)
  `[:concat ,label [:str ": "] ,(or value [:str ""])])

(majutsu-tpl [:my-helper [:str "ID"] [:str "VAL"]])
; => "concat(\"ID\", \": \", \"VAL\")"
@end lisp

@node Type System
@section Type System

The DSL supports Jujutsu's type system: @samp{String}, @samp{Boolean}, @samp{Integer}, @samp{Template}, @samp{Commit}, @samp{Signature}, @samp{Timestamp}, @samp{List}, @samp{Option}, and more. Type annotations can be added to @samp{:raw} nodes:
@lisp
[:raw "self" :Commit]  ; Declares the raw value has type Commit
@end lisp

@node Supported Commands
@section Supported Commands

Templates can be used with these jj commands:

@multitable {aaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaa}
@headitem Command
@tab Self Type
@item log
@tab Commit
@item show
@tab Commit
@item evolog
@tab CommitEvolutionEntry
@item diff
@tab TreeDiffEntry
@item bookmark list
@tab CommitRef
@item tag list
@tab CommitRef
@item file annotate
@tab AnnotationLine
@item file list
@tab TreeEntry
@item file show
@tab TreeEntry
@item op log
@tab Operation
@item op show
@tab Operation
@item workspace list
@tab WorkspaceRef
@end multitable

@node Extending Majutsu
@chapter Extending Majutsu

@menu
* Module Architecture::
* Process Execution::
* Section Types::
* Transient Definitions::
@end menu

@node Module Architecture
@section Module Architecture

Majutsu is modular. New features should be added as separate files (e.g., @samp{majutsu-feature.el}) and use the core APIs in @samp{majutsu-core.el} and @samp{majutsu-process.el}.

@node Process Execution
@section Process Execution

Use @samp{majutsu-run-jj} for commands that modify the repo and require a refresh, or @samp{majutsu-jj-string} to get command output as a string.

@node Section Types
@section Section Types

Majutsu defines several Magit section types: @samp{jj-commit}, @samp{jj-file}, @samp{jj-hunk}, and @samp{jj-workspace}. You can define custom keymaps for these sections using @samp{defvar-keymap}.

@node Transient Definitions
@section Transient Definitions

New commands should be exposed via @samp{transient-define-prefix}. Refer to @samp{majutsu-rebase.el} for examples of complex multi-step selections.

@node Keystroke Index
@appendix Keystroke Index

@printindex ky

@node Function and Command Index
@appendix Function and Command Index

@printindex fn

@node Variable Index
@appendix Variable Index

@printindex vr

@bye
