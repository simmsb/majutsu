#+title: Majutsu Specifications

拉到本地到 org-mode 中阅读能获得更好的阅读体验

* Majutsu Buffers
** majutsu-log
这是我们主要工作在的buffer
因为不像 git 最常用的是 status，在 jj 中 log 反而是更加常用的命令

*** DONE track current revision
magit log section 需要同时存在 change_id 和 commit_id
这样才能在 squash rebase 等会修改 commit_id 的操作之后才能track到正确的section

这应该是非常重要的功能，
相比之下，默认的跳到 @ 可以直接按 ~.~ 来实现

当前实现：
fn:majutsu-parse-log-entries 解析 =change_id= 并把它存到 section value 以及 =majutsu-log-entry-section= 的 =change-id= slot 里。
fn:magit-section-ident-value 对 majutsu log entry 以 =change_id= 为主键，fallback 到 =commit_id=。
fn:majutsu-log-refresh 刷新前记录当前 section 的 =change_id=，刷新后优先用 =change_id= 定位，否则退回 =commit_id=，都失败时跳转到 =@=。
fn:majutsu-log--commit-id-at-point 在 =commit_id= 缺失时返回 =change_id=，保证下游命令用的是稳定标识。

*** TODO builtin avy support
由于 change-id 的设计本来就在高亮唯一前缀
我们完全可以用 avy 的模式来进行跳转！

*** 窗口管理
magit 的buffer都是直接占满全屏，我不想要这样的设计。

我认为让一个 jujutsu log buffer 长时间占在一个窗口里是十分常用的状态
（连续多次的 checkout 是正常的操作），
所以我们默认分屏使用

如果当前只有一个窗口，就分一个窗口，退出时恢复为一个窗口；
如果当时有多个窗口，占据除了当前窗口之外的某一个窗口，退出时恢复那个被占据 buffer。

** message buffer

*** TODO 完全使用 with-editor 方案

这是一种完全没有兼容性问题的方案，之后考虑在适当的时候完全转到这个方案上

**** with-editor 文件定位

jj 在需要编辑描述信息的时候，会把待编辑的描述文件放在临时目录 =/tmp/= 下，
命名格式为 =editor-XXXXXX.jjdescription=，其中 =X= 可能是数字、大小写字母混合。
需要以这个模式为依据（正则大致是 =/tmp/editor-[0-9A-Za-z]+\.jjdescription=）
去匹配 =with-editor-server-window-alist=，确保描述文件落回 majutsu 的 log 窗口，
而不是打断用户原本的窗口布局。

*** 窗口管理

在打开 message buffer 的时候有两种状态：
1. 在 log buffer 内
2. 不在 log buffer 内

如果当前只有一个窗口，我们希望分屏

如果有两个，如果另一个不是 log buffer 就用另一个
如果另一个是 log buffer 就用这一个


*** TODO 附加 diff 信息

** diff view
采用了基于 =magit-section= 的专用 =majutsu-diff-mode=，提供结构化的差异展示。

*** 交互式 Diff (Transient)
~D~ 绑定到 fn:majutsu-diff-transient，提供了类似 Magit 的交互体验：
- *动态选区*：在日志视图中，使用 ~f~ (From) 和 ~t~ (To) 动态选择并高亮修订版范围。
- *智能执行*：~d~ (Execute) 会自动识别选区；若无选区，则智能回退到对比当前提交或工作副本。
- *常用选项*：菜单中直接提供 ~--stat~, ~--summary~, ~--git~ 等常用开关。

*** Diff 缓冲区特性
- *结构化展示*：完整复用了 log buffer 中 "Working Copy Changes" 的解析逻辑，支持文件和 Hunk 级别的折叠/展开。
- *源码跳转*：支持使用 ~RET~ 直接从 Hunk 跳转到对应源文件的具体行号。
- *上下文恢复*：使用标准的 =quit-window= (~q~) 和 =pop-to-buffer= 管理窗口，确保顺滑的工作流体验。
- *稳定刷新*：~g~ 键能记住最初生成此 Diff 的完整参数并重新执行，确保视图稳定。

*** diffedit 现状

~E~ 触发 fn:majutsu-diffedit-emacs ：若光标在文件/补丁 section 内直接针对该文件调用 ediff；
否则走 fn:majutsu-diffedit-all ，通过 ~jj diff --name-only~ + ~completing-read~ 选择目标文件。

ediff 模式通过 fn:majutsu-diffedit-with-ediff 创建父修订临时文件（~jj file show -r @- <file>~），
quit 时清理临时文件并自动 ~majutsu-log-refresh~，提示左右 buffer 的角色，鼓励用户在右侧编辑。

~M~ 触发 fn:majutsu-diffedit-smerge ，构造伪冲突格式的 buffer（Parent vs Current），
启用 ~smerge-mode~ 并把保存回写交给 fn:majutsu-smerge-apply-changes ，要求冲突标记全部解决后才覆盖工作区。

所有 diffedit 入口都集中调用 ~majutsu--get-changed-files~ 与 ~majutsu-diffedit-all~，避免需要 jj 的 ~diffedit~ 外部工具；
后续如要支持多文件批量编辑，可在此基础上扩展。

* Transient Views
** command view
** log view
** squash view
** bookmark view
*** list
**** TODO 高亮显示
**** TODO 支持到跳转焦点到对应的 log view entry
*** move
**** DONE 支持 -B
要把 bookmark 往前移需要设置 --allow-backwards
打算设置到 M 上
** rebase view
** git view

* Operations
** new
需要两种模式
一种是直接在当前 revset 新建
一种是进入一个多选模式，可以 toggle 不同的参数对应的 revset 集
这里可以借鉴 rebase transient 的设计

*** 快捷模式（direct new）
继续复用 ~N~ 键；无前缀时直接在当前光标所在的 changeset 上执行 ~jj new~，选中节点成为默认的唯一父节点。
如果当前无法识别 changeset（例如 log buffer 为空），则 fallback 到 ~@~（working copy）。
~C-u N~ 直接进入 transient，进行父节点/参数的精细选择。
执行成功后刷新 log，并在可能情况下跳回新的 ~@~。

*** Transient 模式（majutsu-new-transient）
- 新增命令 ~majutsu-new-transient~，默认提供在 ~majutsu-dispatch~ 菜单中；不强绑按键，避免覆盖 ~magit-section~ 的导航键。
- 进入 transient 后沿用 rebase transient 的 overlay 模式，三种状态分别高亮：
  - <REVSETS>：父节点集合，按 ~p~ 在光标处 toggle；使用 ~[PARENT]~ label 及 ~(:background "dark orange" :foreground "black")~。
  - ~-A/--after~：插入位置的父节点，按 ~a~ toggle；使用 ~[AFTER]~ label 及 ~(:background "dark blue" :foreground "white")~。
  - ~-B/--before~：插入位置的子节点（多选），按 ~b~ toggle；使用 ~[BEFORE]~ label 及 ~(:background "dark magenta" :foreground "white")~。
- ~m~ 用于一次性输入提交信息，映射到 ~--message~；~e~ toggle ~--no-edit~。
- ~RET~ 和 ~n~ 触发执行；命令行参数按以下顺序拼装：
  1. <REVSETS> 列表（为空时默认 ~@~）。
  2. 每个 ~-A~ / ~--after~ 目标按选择顺序展开。
  3. 每个 ~-B~ / ~--before~ 目标按选择顺序展开。
  4. 可选的 ~--message~ 与 ~--no-edit~。
- ~c~ 清除所有选择；~q~ 退出时自动清理 overlay 与内部 state。

*** 状态建模
- 维护 ~majutsu-new-parents~、~majutsu-new-after~、~majutsu-new-before~ 三个列表，以及对应 overlay 列表。
- 退出 transient（含执行成功）时统一清理 state。
- 复用 ~majutsu-log--revset-at-point~ 判断当前 changeset id（优先 ~change_id~），保持与其他 transient helper 的一致。
- 抽取一个 ~majutsu-new--build-args~ 辅助函数，集中拼装命令参数，便于 ERT 覆盖。
- 引入统一的 ~<REVSET>~（单选）与 ~<REVSETS>~（多选） selection helper，命令只需提供 label/face 与 state 变量即可复用，内部统一记录 ~change_id~ 以保持 rewrite 后的稳定性，必要时再回退到 ~commit_id~。
- 选项状态同时缓存 ~commit_id~，检测到 change rewrite (~change_id~ 相同但 ~commit_id~ 不同) 时自动刷新 log buffer 并重新附着 overlay。

*** TODO
- 与 rebase transient 共享 overlay/util helper，减少重复逻辑。
- 覆盖以下测试：
  - overlay 状态切换（父/after/before）。
  - ~majutsu-new--build-args~ 参数拼装。
  - ~--no-edit~ 与 ~--message~ 交互路径。

** duplicate
我觉得也挺重要的，需要支持

** split
这是 jj-mode.el 还没有实现的功能，我想要把它实现了

=--tool :builtin=
[[https://github.com/arxanas/scm-record?tab=readme-ov-file#scm-diff-editor][scm-record]] 中的 scm-diff-editor
是jj内置的默认编辑工具

可以参考 [[https://github.com/ilyagr/diffedit3][diffedit3]] 的实现

我觉得我可以解决一次只能 split 一个 rev 的限制！

每个changeset是基于前一个 rev 的

如果设成 =--tool emacs= 在默认下的行为：
他创建了两个临时目录，只包含当前 changeset 涉及到的文件
把当前 changeset 应用前放在了 left 目录里
把当前 changeset 应用后的文件放在了 right 目录里
然后对right修改得到的 changeset，是你想插入的中间的 rev
然后当前 changeset 就是原先 changset 和这个你编辑得到的 changeset 取反

如何设计进行连续的多个 split？
split 产生的 rev 是否必须是一条链？我觉得应该是？
我如何处理树状视图？
