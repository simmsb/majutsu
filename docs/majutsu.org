#+title: Majutsu User Manual
#+author: 0WD0
#+email: wd.1105848296@gmail.com
#+texinfo_dir_category: Emacs
#+texinfo_dir_title: Majutsu: (majutsu).
#+texinfo_dir_desc: Using Jujutsu from Emacs with Majutsu.
#+subtitle: for version 0.6.0
#+options: broken-links:mark

Majutsu is a Magit-inspired Emacs interface for the Jujutsu (jj) version control system. It provides a powerful, interactive log viewer and a comprehensive set of commands for manipulating revision history with the efficiency and comfort Emacs users expect.

* Introduction
** About Majutsu
Majutsu aims to bring the legendary workflow of Magit to the Jujutsu (jj) version control system. It is not merely a wrapper around the =jj= CLI, but a deeply integrated Emacs environment that leverages Magit's section management and transient menu systems. Majutsu provides visual tools for complex operations like rebasing, squashing, and conflict resolution, making the power of Jujutsu accessible and intuitive.

Originally started as a fork of =jj-mode.el=, Majutsu has been heavily refactored and expanded to include a new template DSL, asynchronous process handling, and a native Evil-mode integration.

** About Jujutsu
Jujutsu (jj) is a next-generation version control system that is both simple and powerful. It features a unique "working copy is a commit" model (@), first-class support for mutable history, and robust conflict management. Unlike Git, jj does not have a staging area; instead, changes in the working copy are automatically recorded into the current revision. This makes it an ideal companion for Emacs, where buffers are often in a state of flux.

** Acknowledgments
Majutsu stands on the shoulders of giants. We are grateful to:
- The Jujutsu community for creating a revolutionary VCS.
- The Magit authors and contributors for defining the gold standard of VCS interfaces.
- Brandon Olivier for the initial codebase of =jj-mode.el=.

* Installation
** Requirements
- Emacs 29.1 or later.
- Jujutsu (jj) v0.37.0 or later installed and in your =PATH=.
- =magit= 3.3.0 or later (for section management).
- =transient= 0.5.0 or later (popup menus).
- =with-editor= (for descriptive message editing).

** Installing from Git
Majutsu is currently available via GitHub. You can install it using your preferred Emacs package manager.

*** Doom Emacs
Add the following to your =packages.el=:
#+begin_src emacs-lisp
(package! majutsu :recipe (:host github :repo "0WD0/majutsu"))
#+end_src

*** use-package with straight.el
#+begin_src emacs-lisp
(use-package majutsu
  :straight (:host github :repo "0WD0/majutsu"))
#+end_src

*** use-package with package-vc
Emacs 29+ users can use the built-in =package-vc= support:
#+begin_src emacs-lisp
(use-package majutsu
  :vc (:url "https://github.com/0WD0/majutsu"))
#+end_src

*** Manual Installation
Clone the repository and add it to your =load-path=:
#+begin_src emacs-lisp
(add-to-list 'load-path "/path/to/majutsu")
(require 'majutsu)
#+end_src

** Post-Installation Tasks
If you use Evil mode, Majutsu includes a native integration that provides sensible Vim-like keybindings. It is enabled by default if Evil is detected. You can customize this via =M-x customize-group RET majutsu-evil RET=.

* Getting Started
To begin using Majutsu, navigate to a directory within a Jujutsu repository and run ~M-x majutsu-log~ (or its alias ~majutsu~).

If the directory is not a repository, Majutsu will offer to initialize one using =jj git init=. Once the log buffer opens, you will see a graphical representation of your revision history, similar to Magit's log but with Jujutsu's unique features like hidden and divergent revisions clearly marked.

Navigation is straightforward: use ~n~ and ~p~ to move between revisions, and ~RET~ to visit the revision at point. Press ~?~ at any time to open the Dispatcher, which shows all available commands.

* Interface Concepts
** Buffers and Modes
Majutsu uses several specialized buffer types to provide a rich interface.

*** Log Buffer
The primary interface for Majutsu. It displays the revision graph, working copy status, and active workspaces. It uses =majutsu-log-mode=, derived from =magit-section-mode=.

*** Diff Buffer
Displays changes between revisions or within the working copy. It supports Magit-style hunk and file sections, word-level refinement, and interactive patching.

*** Blob Buffer
Allows viewing the contents of a file at a specific revision. You can navigate through the file's history using ~n~ and ~p~ within the blob buffer.

*** Process Buffer
Shows the output of background =jj= commands. If a command fails, you can press ~$~ to inspect the error.

*** JJ description Buffer
Used for writing commit descriptions or other interactive input. It uses =with-editor= to ensure seamless integration with the Emacs environment.

JJ descriptions buffers highlight metadata blocks and change summaries. You can customize ~majutsu-jjdescription-major-mode~, ~majutsu-jjdescription-comment-prefix~, ~majutsu-jjdescription-change-id-face~, and ~global-majutsu-jjdescription-mode~ to taste. JJ comment commands use ~JJ:~ as the comment prefix. ~JJ: ignore-rest~ marks the remainder of the buffer as comment. Other major modes are not thoroughly tested yet. Jujutsu currently does not support changing the comment prefix; the option is reserved for future compatibility.

** Sections
Majutsu organizes information into collapsible sections. You can use ~TAB~ to toggle the visibility of a section (e.g., a revision's description in the log, or a file in a diff).

** Transient Menus
Commands in Majutsu are grouped into "transient" menus. These popups allow you to select options and flags before executing a command. For example, pressing ~r~ opens the Rebase transient.

** Visual Selection System
For commands like Rebase, Squash, or Absorb, Majutsu uses a visual selection system. You can mark "source" and "destination" revisions directly in the log buffer, and they will be highlighted with distinct colors until the operation is executed or cleared.

** Completion and Confirmation
Majutsu integrates with Emacs' completion system (like Vertico or Ivy) for selecting bookmarks, remotes, and revsets. Revset completion candidates are annotated with source labels (pseudo/workspace/bookmark/tag) to make ambiguous names easier to identify. Destructive operations like ~abandon~ or ~undo~ will prompt for confirmation.

** Running JJ
Majutsu runs =jj= commands asynchronously whenever possible to keep the Emacs UI responsive. Large log graphs or remote operations won't freeze your editor.

* Inspecting
** Log Buffer
The log buffer is the heart of Majutsu. It displays the history graph using a custom template DSL that mirrors the =jj log= output but adds interactivity.

*** Log Display
Each revision in the log is a section. You can see the change ID, bookmarks, tags, and the first line of the description. Collapsed by default, you can expand a revision to see its full description.

*** Log Options Transient
Press ~l~ to open the log options. Here you can:
- ~r~ :: Set a revset filter (e.g., =all()= or =mine()=).
- ~-n~ :: Limit the number of revisions shown.
- ~-v~ :: Toggle reverse order.
- ~-G~ :: Toggle the ASCII graph.
- ~--~ :: Add fileset/path filters to limit the log to matching files.

*** Revset Builder
While you can type revsets manually, Majutsu's selection system allows you to build them interactively. Commands that require a revset will often default to the revision at point or your current selection.

** Diffing
*** Diff Transient
Press ~d~ to open the Diff transient.
- ~r~ :: Select revisions to diff (=--revisions=). Can specify multiple revisions or a revset like =B::D=.
- ~f~ / ~t~ :: Select the =--from= and =--to= revisions.
- ~--~ :: Limit diff to selected files/filesets.
- ~-g~ :: Toggle Git-style diff output.
- ~-W~ :: Toggle color-words diff output.
- ~-S~ :: Toggle stat output.
- ~-s~ :: Toggle summary output.
- ~-c~ :: Set context line count.
- ~-b~ / ~-w~ :: Ignore whitespace amount / ignore all whitespace.

**** Understanding =--revisions=
The =--revisions= argument accepts any revset that forms a /contiguous/ set of commits. "Contiguous" means no gaps in the DAG, but *forks and merges are allowed*.

Examples:
- =-r @= :: Changes in the working copy commit (default).
- =-r @-= :: Changes in the parent of the working copy.
- =-r B::D= :: Total changes from B through D.
- =-r 'A | B'= :: Valid only if A and B form a contiguous set; gaps produce an error.

When visiting a file from such a diff:
- On an *added* or *context* line: visits =heads(revisions)=.
- On a *removed* line: visits =roots(revisions)-= (the parents of roots).

*Note*: When the revset has multiple heads or roots, the target revision for file visits may be ambiguous. For example, in an X-shaped history:
#+begin_example
  D   E       <- two heads
   \ /
    C
   / \
  A   B       <- two roots
#+end_example
If you diff =-r A::D | B::E=, there are two heads (D, E) and two roots (A, B). The diff shows changes from the /merged/ parents to the /merged/ heads. If D and E modify the same lines, the diff will show conflict markers. When visiting files, Majutsu picks one of the heads/roots, which may not be the specific commit where the displayed change originated. For precise navigation, use =--from= / =--to= with single revisions instead.

*** Diff Buffer
The diff buffer is highly interactive:
- ~RET~ :: Visit the appropriate version of the file at point. For working copy diffs, added/context lines visit the workspace file while removed lines visit the parent-side blob. For committed changes, it visits the blob at the corresponding side.
- ~C-j~ / ~C-<return>~ :: Visit the workspace file, regardless of diff type. Note: when Evil mode is active, ~C-j~ may be overridden by Evil's section navigation; use ~C-<return>~ instead, which is unaffected.
- ~v~ (on a file section) :: Open a blob buffer for that file using the current diff context.
- ~+~ / ~-~ :: Increase or decrease the amount of context shown.
- ~t~ :: Toggle word-level refinement.

When =--color-words= is enabled, Majutsu renders the old/new line numbers in
the left margin and uses "..." lines to split hunks.
With refinement enabled, color-words hunks also show a shadow cursor on the
paired side (controlled by =smerge-refine-shadow-cursor=).
Navigation (=RET= / =C-j=) still respects the side at point by using stored
line/column metadata from the color-words backend.

** File and Blob Inspection
Majutsu's file inspector is implemented by =majutsu-file= and can be used both
from command prompts and directly from sections in log/diff buffers.

- ~M-x majutsu-find-file~ :: Prompt for revset + path and open that file as a blob.
- ~M-x majutsu-find-file-at-point~ :: Open the file at point using section context.

Blob buffers are read-only snapshots with history-aware navigation:
- ~p~ / ~n~ :: Jump to previous/next revision that touched this file (while preserving cursor position as much as possible).
- ~V~ :: Jump to the workspace version of the same file.
- ~C-c m~ :: Open the current blob in Magit's blob viewer.
- ~b~ :: Start annotate for the current blob.
- ~g~ :: Revert/reload the current blob content.
- ~e~ / ~C-x C-q~ :: Enter editable blob mode (wdired-style).
  - Blob navigation keys are disabled while editing, so blob-mode bindings do not interfere with text edits.
  - Save (or ~C-c C-c~) applies changes through non-interactive =jj diffedit= and exits edit mode.
    Majutsu copies current buffer text into the diffedit right side and finishes automatically, without opening the right-side temp file buffer.
  - In editable mode, ~C-x C-q~ runs ~majutsu-blob-edit-exit~:
    - If modified, it prompts to save or abort.
    - Save applies via diffedit; abort restores original content and cursor position.
    - If unchanged, it exits immediately.
  - In Evil:
    - In blob mode, ~i~ enters editable blob mode and stays in normal state.
    - In editable mode, ~i~ enters insert state.
  - Editable mode also changes cursor visuals (see ~majutsu-blob-edit-cursor-type~); with Evil, normal-state cursor is updated too.

** Annotate (Blame)
Majutsu annotate is implemented by =majutsu-annotate= and uses
=jj file annotate= under the hood.

- Entry: run ~b~ (~majutsu-annotate-addition~) from a blob/file buffer.
- Recursive trace: currently only forward recursive annotate is supported.
  Running ~b~ again on an annotated chunk jumps to its parent revision (when
  available) and re-annotates there.
- Styles: ~majutsu-annotate-cycle-style~ is available. In default
  read-only annotate bindings, press ~c~ to cycle heading/highlight/line styles
  (=majutsu-annotate-styles=).
- Navigation: ~n~ / ~p~ for next/previous chunk, ~N~ / ~P~ for next/previous
  chunk from the same commit.
- Inspection: ~RET~ shows the chunk's revision diff, ~M-w~ copies the chunk
  change-id, and ~SPC~ / ~S-SPC~ scroll the diff window if it is already open.

** Ediff and Diffedit
Press ~E~ in dispatcher to open =majutsu-ediff= transient.

- Selection: choose revisions via =--revisions= or =--from= / =--to= (with
  point-toggle variants). In diff buffers, current range is used as default.
- ~e~ (=majutsu-ediff-dwim=) :: Compare based on context (hunk/file/commit/whole
  buffer).
- ~E~ (=majutsu-ediff-edit=) :: Run =jj diffedit= with Emacs as
  =ui.diff-editor=. If no file is at point, Majutsu prompts for a changed file,
  then launches a two-sided Ediff session for that single file (left/right
  temp files). Edit the right-side temp file and quit Ediff to return control
  to =jj diffedit=. When =majutsu-edit-finish-on-save= is non-nil, saving a
  diffedit temp file can finish the with-editor session automatically.

Resolve entry points:
- Ediff transient: ~m~ (=majutsu-ediff-resolve=),
  ~M~ (=majutsu-ediff-resolve-with-conflict=).
- Direct commands: =M-x majutsu-ediff-resolve=,
  =M-x majutsu-ediff-resolve-with-conflict=.

- ~m~ (=majutsu-ediff-resolve=) :: Resolve conflicted files.
  In a =jj-commit= section, it lists conflicted files for that revision;
  otherwise it uses working copy =@=. Uses =jj resolve= with 3-way Ediff
  (merge tool: =$left=, =$base=, =$right=) for up-to-2-sided conflicts, and
  falls back to =jj diffedit= for conflicts with more than 2 sides.
  In this flow, quitting Ediff without editing leaves jj's output unchanged,
  so the conflict stays unresolved. If you edited and quit, Majutsu asks whether
  to save the resolved result; choosing no discards edits and keeps conflicts.
  When only part of a conflict is resolved, remaining regions are written with
  git-style conflict markers so jj keeps unresolved regions unresolved.
- ~M~ (=majutsu-ediff-resolve-with-conflict=) :: Open the resolve target
  buffer (working-copy file or revision blob), enable
  =majutsu-conflict-mode=, and jump to the first conflict.

** Process Buffer
Press ~$~ (Emacs) or ~`~ (Evil) to see the output of the last =jj= command. This is essential for debugging failed operations or viewing long-running output like remote fetches.

** Operation Log (Experimental)
Jujutsu tracks every operation that modifies the repository. Press ~M-x majutsu-op-log~ to view this history. You can see when commands were run and by whom.

* Manipulating
** Creating Changes
- ~O~ :: Create a new change on top of the revision at point (DWIM).
- ~o~ :: Open the New transient to specify options.
- ~A~ :: Create a new change after the revision at point.
- ~B~ (Emacs), ~I~ (Evil log mode) :: Create a new change before the revision at point.

Transient options:
- ~-r~ :: Parent revisions.
- ~-A~ :: Insert after constraint.
- ~-B~ :: Insert before constraint.
- ~-m~ :: Set a message.
- ~-e~ :: No edit (don't switch to the new change).
Runs: =jj new -r REV=

** Describing Changes
- ~c~ (~majutsu-describe~) :: Edit the description of the revision at point. Supports =--ignore-immutable= flag for immutable revisions.
Runs: =jj describe -r REV=

** Committing
- ~C~ (~majutsu-commit~) :: In Jujutsu, "commit" usually means finishing the current work. This command opens a description buffer for the working copy.
Runs: =jj commit=

** Editing Changes
- ~e~ (~majutsu-edit-changeset~) :: Move the working copy (@) to the revision at point. Supports =--ignore-immutable= flag for immutable revisions.
Runs: =jj edit REV=

** Squashing
- ~s~ (~majutsu-squash~) :: Open the Squash transient. You can select multiple source revisions (=--from=) to squash into a destination (=--into=).
- ~-r~ :: Revision to squash.
- ~-f~ :: Source revisions (=--from=).
- ~-t~ :: Destination revision (=--into=).
- ~-o~ :: Onto destination.
- ~-A~ / ~-B~ :: Insert after/before constraints.
- ~--~ :: Limit squash to specific filesets.
- ~-k~ :: Keep commits that become empty after squashing.
Runs: =jj squash --from SRC --into DEST [FILESETS...]=

** Absorbing
- ~a~ (Emacs/Evil), or ~?~ then ~A~ (~majutsu-absorb~) :: Open the Absorb transient.
- ~-f~ :: Source revision (=--from=, default =@=).
- ~-t~ :: Destination revset filter (=--into=, default =mutable()=).
- ~--~ :: Limit absorb to specific filesets.
Runs: =jj absorb --from REV --into REVSET [FILESETS...]=

** Rebasing
- ~r~ (~majutsu-rebase~) :: Open the Rebase transient. This is one of Majutsu's most powerful features, allowing you to visually select sources and destinations.
- ~-s~ :: Rebase a specific revision.
- ~-b~ :: Rebase an entire branch.
- ~-o~ :: Specify the destination (=--onto=).
Runs: =jj rebase -s SRC -o DEST=

** Duplicating
- ~y~ (~majutsu-duplicate~) :: Open the Duplicate transient. Allows selecting source revisions and destination.
- ~Y~ (~majutsu-duplicate-dwim~) :: Duplicate the revision at point onto its current parent.
- ~-r~ :: Source revisions to duplicate.
- ~-o~ :: Destination (=--onto=).
- ~-A~ / ~-B~ :: Insert after/before constraints.
Runs: =jj duplicate -r REV=

** Abandoning
- ~k~ (Emacs), ~x~ (Evil) :: Abandon the revision at point. Its changes are lost, and its descendants are rebased.
  With an active region selection, Majutsu abandons all selected revisions.
Runs: =jj abandon -r REV=

** Undo and Redo
- Emacs: ~C-/~ / ~C-?~ :: Undo / Redo
- Evil: ~u~ / ~C-r~ :: Undo / Redo
Runs: =jj undo= or =jj redo=

** Splitting
- ~S~ (~majutsu-split~) :: Open the Split transient. This allows you to split a revision into multiple parts.
- ~-r~ :: Specify the revision to split.
- ~-o~ :: Specify the destination (=--onto=).
- ~-A~ / ~-B~ :: Insert after/before constraints.
- ~-m~ :: Set a message for the first part.
- ~-p~ :: Parallel split mode.
- ~--~ :: Limit split to selected files/filesets.
Runs: =jj split -r REV [FILESETS...]=

** Restoring
- ~R~ (~majutsu-restore~) :: Open the Restore transient for undoing changes.
- ~-f~ :: Restore from a specific revision (=--from=).
- ~-t~ :: Restore to a specific revision (=--to=).
- ~-c~ :: Undo changes introduced by a revision (=--changes-in=).
- ~-d~ :: Restore descendants as well.
- ~--~ :: Limit restore to selected files/filesets.
Runs: =jj restore --from REV [FILESETS...]= or =jj restore --changes-in REV [FILESETS...]=

** Reverting
- ~V~ (Emacs), ~_~ (Evil) (~majutsu-revert~) :: Open the Revert transient to create reverse changes in a new revision.
- ~-r~ :: Source revisions to revert (=--revisions=).
- ~-o~ :: Apply reverse changes on top of revisions (=--onto=).
- ~-A~ / ~-B~ :: Insert reverse changes after/before selected revisions.
Runs: =jj revert --revisions REV --onto DEST=

** Sparse Working Copy
- ~>~ (~majutsu-sparse~) :: Open the sparse working copy transient (set, add, remove, list, edit).
- Editing patterns opens a temporary =.jjsparse= buffer; lines starting with ~JJ:~ are comments and are ignored by Jujutsu.

Sparse transient actions:
- ~l~ :: List current sparse patterns in =*Majutsu Sparse*= buffer.
- ~s~ / ~S~ :: Set patterns (append / replace with clear first).
- ~a~ / ~r~ :: Add or remove patterns incrementally.
- ~e~ :: Edit patterns via =jj sparse edit= (with =majutsu-jjsparse-mode=).
- ~R~ :: Reset to all files (=jj sparse reset=).

Notes:
- Pattern completion includes current directories/files from =@=.
- Default "all files" state is represented by single pattern =.=.

** Interactive Patching
Majutsu provides Magit-style partial hunk selection for Jujutsu operations. This allows you to select specific hunks, files, or even regions within hunks to include in Split, Squash, or Restore operations.

*** How It Works
Interactive selection is integrated into the Split (~S~), Squash (~s~), and Restore (~R~) transients. When you open one of these transients from a Diff buffer, a "Patch Selection" group appears with the following commands:

| Key | Command                           | Description                           |
|-----+-----------------------------------+---------------------------------------|
| ~H~   | majutsu-interactive-toggle-hunk   | Toggle selection of hunk at point     |
| ~F~   | majutsu-interactive-toggle-file   | Toggle selection of all hunks in file |
| ~R~   | majutsu-interactive-toggle-region | Toggle selection of active region     |
| ~C~   | majutsu-interactive-clear         | Clear all patch selections            |

*** Diff Context Inheritance
When opening Split, Squash, or Restore from a Diff buffer, the transient automatically inherits the diff's context:
- All three commands inherit =--revisions= as their target revision (=--revision= for Split/Squash)
- Restore additionally inherits =--from= and =--to= parameters, allowing selective restoration between arbitrary revisions

This means you can:
1. View a diff with specific =--from= / =--to= revisions
2. Open the Restore transient
3. Select specific hunks to restore
4. The restore will apply only to those hunks, using the diff's revision context

*** Visual Feedback
Selected hunks are highlighted with =majutsu-interactive-selected-hunk= face (green background by default). Selected regions within hunks use =majutsu-interactive-selected-region= face (purple background).

*** Selection Semantics
The meaning of "selected" differs by operation:

**** Split and Squash
For Split and Squash, *selected content is what gets moved*:
- *Split*: Selected hunks/regions go into the *first* commit; unselected content stays in the second commit.
- *Squash*: Selected hunks/regions get *squashed into the parent*; unselected content remains in the current revision.

Example: You have a revision with changes to files A, B, and C. You want to squash only the changes to file A into the parent:
1. Open the diff for the revision (~D~)
2. Open Squash transient (~s~)
3. Press ~F~ on file A to select all its hunks
4. Execute squash - file A's changes go to parent, B and C stay

**** Restore
For Restore, selected content is what gets *restored* (undone):
- Selected hunks/regions are reverted to their state in the source revision
- Unselected content is left unchanged

*** Technical Implementation
Majutsu uses a custom merge tool to apply partial patches. When you execute an operation with selections:

1. *Patch Generation*: Majutsu generates a unified diff patch containing only the selected hunks/regions.

2. *Tool Invocation*: Jujutsu's =-i --tool= mechanism is used with a custom =majutsu-applypatch= tool.

3. *Patch Application*:
   - For *Split/Squash*: The tool resets =$right= (current state) to =$left= (parent state), then applies the patch forward. This results in =$right= containing only the selected changes.
   - For *Restore*: The tool applies the patch directly to =$right=.

This approach avoids the complexity of reverse patch application (=git apply -R=), which has edge cases with new files, deleted files, and content starting with =+= or =-=.

*** Edge Cases
Interactive patching supports all file operation types:

**** New Files
When splitting or squashing a new file:
- If you select the entire file, it goes to the first commit / gets squashed
- If you select only part of the file, only those lines go; the rest stays
- Partial selection of new files works correctly because the patch is applied forward after resetting to parent state

**** Deleted Files
*Note: Interactive selection for deleted files is currently limited.*

When splitting or squashing a file deletion:
- Selecting the *entire* deletion works correctly - the file gets deleted in the first commit / parent
- *Partial selection of deleted files is not yet supported* - you must select all lines or none

This limitation exists because git's patch format requires =deleted file mode= patches to remove the entire file contents. Partial deletion would require converting to a regular modification patch, which has edge cases with context matching.

**** Renamed/Copied Files
Renamed and copied files are handled correctly:
- The rename/copy metadata is preserved in the patch
- You can select specific hunks within renamed files just like regular modifications

*** Workflow Example
1. Open a diff with ~D~ or ~d~
2. Open Split (~S~), Squash (~s~), or Restore (~R~) transient
3. Use ~H~ to select individual hunks, or ~F~ to select all hunks in a file
4. For fine-grained control, mark a region and press ~R~ to select only those lines
5. Press ~C~ to clear selections if needed
6. Execute the operation - only selected changes will be affected

*** Customization
- =majutsu-interactive-selected-hunk= :: Face for selected hunks
- =majutsu-interactive-selected-region= :: Face for selected regions

* Bookmarks
** Understanding Bookmarks
In Jujutsu, bookmarks are similar to Git branches but are explicitly tracked. They point to a specific change ID.

** Bookmark Transient
Press ~b~ to manage bookmarks.
- ~l~ :: List all bookmarks.
- ~c~ :: Create a new bookmark at point.
- ~s~ :: Set (move) an existing bookmark to point to the current revision.
- ~m~ :: Move a bookmark.
- ~M~ :: Move bookmark(s) with =--allow-backwards=.
- ~r~ :: Rename a bookmark.
- ~d~ :: Delete a bookmark (this deletion propagates to remotes).
- ~f~ :: Forget a bookmark (removes local tracking without affecting remotes).

** Tracking Remote Bookmarks
- ~t~ :: Track a remote bookmark to create a local one.
- ~u~ :: Untrack a remote bookmark.

* Tags
** Understanding Tags
In Jujutsu, tags are lightweight refs that point to revisions, similar to Git tags.
Majutsu wraps =jj tag set/list/delete= and follows jj semantics where creating and
moving tags both use =tag set= (moving requires =--allow-move=).

** Tag Transient
Tag commands are intentionally dispatch-first. Open dispatcher with ~?~, then
press ~t~ to manage tags.
- ~l~ :: List tags in a dedicated buffer.
- ~s~ :: Set tag(s). Uses completion and allows new names.
- ~m~ :: Move existing tag(s) to another revision (internally =--allow-move=).
- ~d~ :: Delete tag(s) by name/pattern.

Tag prompts use completion candidates from local tags. Existing tags are shown for
selection, while set/delete prompts still allow entering string patterns manually.

* Git Integration
** Git Transient
Press ~G~ to access Git-specific commands. Jujutsu can interact directly with Git remotes.

** Pushing
- ~p~ :: Open the Push transient. You can push bookmarks, revisions, or changes.
- ~-a~ :: Push all bookmarks.
- ~-t~ :: Push tracked bookmarks only.
- ~-b~ :: Push specific bookmark(s).
- ~-c~ :: Push a specific change.
- ~-r~ :: Push specific revision(s).
- ~-y~ :: Show what would be pushed without pushing (=--dry-run=).
Runs: =jj git push=

** Fetching
- ~f~ :: Open the Fetch transient to pull changes from a remote.
- ~-R~ :: Fetch from a specific remote.
- ~-B~ :: Fetch a specific branch.
- ~-t~ :: Fetch only tracked bookmarks.
- ~-A~ :: Fetch from all remotes.
Runs: =jj git fetch=

** Remotes
- ~r~ :: Open the Remote Management transient.
- ~l~ :: List remotes.
- ~a~ :: Add a new Git remote.
- ~d~ :: Remove a remote.
- ~n~ :: Rename a remote.
- ~u~ :: Set remote URL.

** Clone and Init
- ~c~ :: Clone a Git repository into a jj repo.
- ~i~ :: Initialize a new Git-backed jj repository.

** Export and Import
Jujutsu automatically exports/imports to the underlying Git repo, but you can trigger it manually:
- ~e~ :: =jj git export=
- ~m~ :: =jj git import=
- ~o~ :: Show Git directory path (=jj git root=)

* Workspaces
** Understanding Workspaces
Jujutsu supports multiple workspaces sharing the same repository storage. This is similar to Git worktrees but more integrated.

** Workspace Transient
Press ~Z~ or ~%~ (Emacs) or ~*~ (Evil) to manage workspaces.
- ~l~ :: List all workspaces.
- ~v~ :: Visit a workspace (only changes default-directory, and refresh majutsu buffers).
- ~a~ :: Add a new workspace.
- ~f~ :: Forget a workspace.
- ~u~ :: Update a stale workspace.
- ~n~ :: Rename a workspace.
- ~r~ :: Show and copy current workspace root.

** Configuring Workspace Discovery
If Majutsu cannot find a workspace on disk, it will prompt you. You can configure =majutsu-workspace-search-directories= to help it find them automatically.

* Conflict Resolution
** Detecting Conflicts
JJ marks conflicts in the log with a "conflict" label. Expanding the revision will show which files are conflicted.

** Entering Conflict Mode
You can enter conflict handling from multiple places:
- In Ediff transient, use ~m~ (auto strategy) or ~M~ (force conflict workflow).
  ~M~ opens the working-copy file (or a revision blob buffer for non-working-copy
  revisions), enables =majutsu-conflict-mode=, and jumps to the first conflict.
- Manually, run ~M-x majutsu-conflict-ensure-mode~ in a file with conflict markers.

=majutsu-conflict= auto-detects marker styles:
- JJ conflict markers (=%%%%%%%= / =+++++++= / =-------= ) -> enable =majutsu-conflict-mode=.
- JJ long conflict markers (e.g., 15-char marker runs) are treated the same as normal markers.
- JJ conflicts with missing terminating newline markers are parsed with jj's newline-compensation semantics.
- Git-style markers (=|||||||= / =======) only -> enable =smerge-mode=.

** majutsu-conflict-mode Commands
Default key prefix is ~C-c ^~:
- ~n~ / ~p~ :: Jump to next/previous conflict.
- ~b~ :: Keep conflict base (snapshot / rebase destination section).
- ~1..9~ :: Keep side N ("after" side in JJ diff blocks).
- ~M-1..M-9~ :: Keep side N "before" variant.
- ~R~ :: Refine conflict regions with word-level highlighting.

In Evil integration:
- ~]]~ / ~[[~ or ~gj~ / ~gk~ :: Next/previous conflict.
- ~gb~ :: Keep base.
- ~gr~ and ~gR~ :: Resolve "after" / "before" side maps.
- ~ge~ :: Refine.

* Customizing
** Essential Settings
- ~majutsu-jj-executable~ :: Path to the =jj= binary (default: ="jj"=).
- ~majutsu-jj-global-arguments~ :: Global arguments passed to all jj commands (default: =("--no-pager" "--color=always")=).
- ~majutsu-show-process-buffer-hint~ :: Whether to show the "Type $ for details" hint on errors.
- ~majutsu-debug~ :: Enable debug logging for jj operations.
- ~majutsu-show-command-output~ :: Show jj command output in messages.

** Confirmation Settings
- ~majutsu-confirm-critical-actions~ :: If non-nil, prompt for confirmation before critical operations like abandon, undo, redo, rebase.
- ~majutsu-no-confirm~ :: A list of symbols for actions Majutsu should not confirm, or =t= to never confirm. Valid symbols: =undo=, =redo=, =abandon=, =rebase=, =workspace-forget=.
- ~majutsu-slow-confirm~ :: A list of actions that should use =yes-or-no-p= instead of =y-or-n-p=.

** Process Options
- ~majutsu-process-popup-time~ :: Popup the process buffer if a command takes longer than this many seconds. =-1= means never, =0= means immediately.
- ~majutsu-process-log-max~ :: Maximum number of sections to keep in a process log buffer (default: 32).
- ~majutsu-process-apply-ansi-colors~ :: When non-nil, convert ANSI escapes in jj output to text properties.
- ~majutsu-process-timestamp-format~ :: Format string for timestamps in process buffer sections.

** Display Options
- ~majutsu-log-commit-columns~ :: Customize which columns are shown in the log (ID, author, date, etc.).
- ~majutsu-log-field-faces~ :: Customize the colors used for different fields in the log.
- ~majutsu-log-sections-hook~ :: Hook run to insert sections in the log buffer.
- ~majutsu-display-buffer-function~ :: Magit-style display strategy (default: =majutsu-display-buffer-traditional=; traditional, same-window-except-diff, fullframe, topleft, fullcolumn).
- ~majutsu-pre-display-buffer-hook~ :: Hook run before displaying a buffer.
- ~majutsu-post-display-buffer-hook~ :: Hook run after displaying a buffer.
- ~majutsu-bury-buffer-function~ :: Function used by ~q~ to bury/quit Majutsu buffers (default: =majutsu-mode-quit-window=; alternatives include =quit-window= and =majutsu-restore-window-configuration=).

** Diff Options
- ~majutsu-diff-refine-hunk~ :: Whether to show word-granularity differences inside hunks. =nil= disables, =t= refines current hunk, ='all= refines all hunks.
- ~majutsu-diff-refine-ignore-whitespace~ :: Whether to ignore whitespace while refining hunks.
- ~majutsu-diff-refine-max-chars~ :: Skip word refinement when a hunk spans more than this many characters.
- ~majutsu-diff-paint-whitespace~ :: Whether to highlight whitespace issues inside diff hunks.
- ~majutsu-diff-highlight-trailing~ :: Whether to mark trailing whitespace in diff hunks.

** Buffer Hooks
- ~majutsu-create-buffer-hook~ :: Normal hook run when a new Majutsu buffer is created.
- ~majutsu-setup-buffer-hook~ :: Normal hook run after displaying the buffer.
- ~majutsu-post-create-buffer-hook~ :: Normal hook run after the initial refresh.
- ~majutsu-refresh-buffer-hook~ :: Normal hook run after refreshing.

** Description Options
- ~majutsu-jjdescription-major-mode~ :: Major mode used for editing JJ description buffers (default: ~text-mode~).
- ~majutsu-jjdescription-comment-prefix~ :: Comment prefix used in JJ description buffers (default: ="JJ:"=).
- ~majutsu-jjdescription-change-id-face~ :: Face used for JJ Change ID values.
- ~global-majutsu-jjdescription-mode~ :: Global minor mode to enable JJ description buffer enhancements.

** Evil Integration
- ~majutsu-evil-enable-integration~ :: Set to =nil= to disable automatic Evil bindings.
- ~majutsu-evil-initial-state~ :: The Evil state to start in (default: =normal=).

** Workspace Options
- ~majutsu-workspace-search-directories~ :: Directories to search when locating workspace roots.

* Template DSL
** Overview
Majutsu includes a domain-specific language (DSL) for building Jujutsu templates in Emacs Lisp. The main entry point is =majutsu-tpl=, which compiles a vector-based DSL form into a jj template string.

** Why Use the DSL?
The DSL provides several advantages over writing raw template strings:

- *Compile-time validation*: Syntax errors are caught during byte-compilation rather than at runtime when jj executes the template.
- *Automatic escaping*: String literals are properly escaped (quotes, backslashes, control characters) without manual intervention.
- *Elisp integration*: Embed Elisp expressions that evaluate at compile time, enabling dynamic template generation based on configuration or context.
- *Composability*: Define reusable template functions with =majutsu-template-defun= that expand inline, avoiding runtime overhead.
- *Type awareness*: The DSL understands jj's type system, enabling self-type context for cleaner keyword syntax (=[:description]= instead of =[:method [:raw "self"] :description]=).
- *Readability*: Vector-based syntax with keywords is more readable than deeply nested string concatenation.

Example comparison:
#+begin_src emacs-lisp
;; Raw string (error-prone, hard to read)
"if(self.root(), \"(root)\", self.commit_id().short())"

;; DSL (validated, composable, readable)
(majutsu-tpl [:if [:raw "self.root()"] "(root)" [:method [:raw "self"] :commit_id :short]])
#+end_src

** Basic Syntax
*** Vectors and Concatenation
Vectors without a leading keyword are implicitly concatenated:
#+begin_src emacs-lisp
(majutsu-tpl ["A" "B"])           ; => "concat(\"A\", \"B\")"
(majutsu-tpl [:concat "A" "B"])   ; => "concat(\"A\", \"B\")"
#+end_src

Bare strings inside vectors are automatically treated as string literals (=:str=).

*** String Literals
Use =:str= for explicit string literals with proper escaping:
#+begin_src emacs-lisp
(majutsu-tpl [:str "Hello \"World\""])  ; => "Hello \"World\""
#+end_src

*** Raw Injection
Use =:raw= to inject template code directly without escaping:
#+begin_src emacs-lisp
(majutsu-tpl [:raw "self.commit_id().short()"])  ; => "self.commit_id().short()"
#+end_src

Symbols passed to =:call= are treated as raw identifiers:
#+begin_src emacs-lisp
(majutsu-tpl [:call 'coalesce [:str ""] [:str "X"]])  ; => "coalesce(\"\", \"X\")"
#+end_src

*** Booleans and Numbers
Elisp =t= and =nil= map to =true= and =false=. Numbers pass through directly:
#+begin_src emacs-lisp
(majutsu-tpl [:if t "yes" "no"])      ; => "if(true, \"yes\", \"no\")"
(majutsu-tpl [:call 'pad_end 8 "x"])  ; => "pad_end(8, \"x\")"
#+end_src

** Method Calls
*** Explicit Method Chaining
Use =:method= to call methods on objects. Methods can be chained:
#+begin_src emacs-lisp
(majutsu-tpl [:method [:raw "self" :Commit] :commit_id])
; => "self.commit_id()"

(majutsu-tpl [:method [:raw "self" :Commit] :parents :len])
; => "self.parents().len()"

(majutsu-tpl [:method [:raw "self" :Commit] :diff "src"])
; => "self.diff(\"src\")"
#+end_src

*** Self-Type Context
When a self-type is provided, bare keywords become method calls on =self=:
#+begin_src emacs-lisp
(majutsu-tpl [:description] 'Commit)      ; => "self.description()"
(majutsu-tpl [:parents :len] 'Commit)     ; => "self.parents().len()"
#+end_src

** List Operations
List methods (=map=, =filter=, =any=, =all=) use a special syntax with a binding variable:
#+begin_src emacs-lisp
(majutsu-tpl [:map [:raw "self.bookmarks()"] b [:raw "b.name()"]])
; => "self.bookmarks().map(|b| b.name())"

(majutsu-tpl [:map-join [:str ", "] [:raw "self.parents()"] p [:raw "p.commit_id()"]])
; => "self.parents().map(|p| p.commit_id()).join(\", \")"

(majutsu-tpl [:filter [:raw "parents"] c [:raw "c.mine()"]])
; => "parents.filter(|c| c.mine())"

(majutsu-tpl [:any [:raw "parents"] c [:raw "c.conflict()"]])
; => "parents.any(|c| c.conflict())"
#+end_src

** Operators
Arithmetic and logical operators are supported:
#+begin_src emacs-lisp
(majutsu-tpl [:+ 1 2])              ; => "(1 + 2)"
(majutsu-tpl [:and [:> 3 1] [:<= 2 2]])  ; => "((3 > 1) && (2 <= 2))"
(majutsu-tpl [:not t])              ; => "(!true)"
(majutsu-tpl [:++ "L" "R"])         ; => "(\"L\" ++ \"R\")"
#+end_src

** Conditional and Control Flow
#+begin_src emacs-lisp
(majutsu-tpl [:if [:raw "self.root()"] "(root)" [:raw "self.commit_id()"]])
; => "if(self.root(), \"(root)\", self.commit_id())"

(majutsu-tpl [:separate " " [:label "a" "A"] [:label "b" "B"]])
; => "separate(\" \", label(\"a\", \"A\"), label(\"b\", \"B\"))"
#+end_src

** Elisp Embedding
Elisp expressions are evaluated when the template is compiled.
#+begin_src emacs-lisp
(let* ((tmp 1)
       (s1 `[:concat ,(if (> 2 tmp) [:str "T"] [:str "F"]) [:str "!"]])
       (s2 [:concat (if (> 2 tmp) [:str "T"] [:str "F"]) [:str "!"]])
       (tmp 3))
  (concat (majutsu-tpl s1) (majutsu-tpl s2)))
; => "concat(\"T\", \"!\")concat(\"F\", \"!\")"
#+end_src

** Defining Custom Functions
Use =majutsu-template-defun= to define reusable template functions:
#+begin_src emacs-lisp
(majutsu-template-defun my-helper ((label Template) (value Template :optional t))
  (:returns Template)
  `[:concat ,label [:str ": "] ,(or value [:str ""])])

(majutsu-tpl [:my-helper [:str "ID"] [:str "VAL"]])
; => "concat(\"ID\", \": \", \"VAL\")"
#+end_src

** Type System
The DSL supports Jujutsu's type system: =String=, =Boolean=, =Integer=, =Template=, =Commit=, =Signature=, =Timestamp=, =List=, =Option=, and more. Type annotations can be added to =:raw= nodes:
#+begin_src emacs-lisp
[:raw "self" :Commit]  ; Declares the raw value has type Commit
#+end_src

** Supported Commands
Templates can be used with these jj commands:

| Command        | Self Type            |
|----------------+----------------------|
| log            | Commit               |
| show           | Commit               |
| evolog         | CommitEvolutionEntry |
| diff           | TreeDiffEntry        |
| bookmark list  | CommitRef            |
| tag list       | CommitRef            |
| file annotate  | AnnotationLine       |
| file list      | TreeEntry            |
| file show      | TreeEntry            |
| op log         | Operation            |
| op show        | Operation            |
| workspace list | WorkspaceRef         |
| config list    | ConfigValue          |

* Extending Majutsu
** Module Architecture
Majutsu is modular. New features should be added as separate files (e.g., =majutsu-feature.el=) and use the core APIs in =majutsu-core.el= and =majutsu-process.el=.

** Process Execution
Use =majutsu-run-jj= for commands that modify the repo and require a refresh, or =majutsu-jj-string= to get command output as a string.

** Section Types
Majutsu defines several Magit section types: =jj-commit=, =jj-file=, =jj-hunk=, and =jj-workspace=. You can define custom keymaps for these sections using =defvar-keymap=.

** Transient Definitions
New commands should be exposed via =transient-define-prefix=. Refer to =majutsu-rebase.el= for examples of complex multi-step selections.

* Keystroke Index
:PROPERTIES:
:APPENDIX:   t
:INDEX:      ky
:END:
* Function and Command Index
:PROPERTIES:
:APPENDIX:   t
:INDEX:      fn
:END:
* Variable Index
:PROPERTIES:
:APPENDIX:   t
:INDEX:      vr
:END:
